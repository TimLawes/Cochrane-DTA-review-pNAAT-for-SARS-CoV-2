---
title: "R Notebook for Cochrane systematic review on pNAAT for SARS-CoV-2"
output:
  html_notebook:
    toc: yes
    toc_float: yes
  word_document:
    toc: yes
  html_document:
    df_print: paged
    toc: yes
  pdf_document:
    toc: yes
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook including code for all analyses within the Cochrane Review on Pooled versus individual nucleic acid amplification testing (pNAAT) for detection of active SARS-CoV-2 infection. It requires the following datasets 

* pnaat_desc_study.csv
* pnaat_desc.csv


# 1. Preliminaries

## 1.1 Check working directory
Open the R project associated with this notebook to ensure the working directory is set to ~/Cochrane-DTA-review-pNAAT-for-SARS-CoV-2

## 1.2 Load packages required
This project will initialise *renv*  when opened. The R package *renv* creates a record of packages required for the project in a linked private package library. This ensures

* Package installations do not over-write your existing (global) package libraries.
* Package versions are the same as those used within this project.

The following call should install (or copy across from your existing global library) packages that are required for the project 
```{r message=FALSE, warning=FALSE}
renv::restore()
```

```{r message=FALSE, warning=FALSE}

library(gtsummary) # to enable creation of print-ready tables
library(gt) # to enable creation of print-ready tables
library(robvis) # for producing risk of bias summary figures
library(lattice)
library(patchwork) # for composite figures
library(mada) # for forest plots
library(metafor) # for forest plots
library(mgcv) # For exploring non-linear relationships between covariates and outcomes using GAM.
library(lme4) # for generalised linear mixed model (GLMM) regression analysis #
library(effects) # To obtain and plot coefficients and residuals from GLM(M)
library(msm) # enables calculation of DOR confidence intervals by delta-method #
library(ggeffects) # provides easy conversion of coefficients to predicted probabilities
library(partR2) # calculates semi-partial (part) R2 indicating % total variance explained by fixed effects of explanatory varaibles in a glmm.
library(DHARMa) # For residual diagnostics on generalised linear models
library(car) # For identifiying multi-colinearity by variable inflation factors (vif)
library(merTools) # For boostrap confidence intervals around fixed effects etc.
library(sjPlot) # For plotting predicted probabilities and model outputs
library(sjmisc)
library(sjlabelled)
library(lmtest)# allows comparison of nested models
library(meta4diag) # allows for Bayesian GLMM
library(rjags)
library(bamdit) # allows for Bayesian GLMM
library(binom) # allows calculation of exact binomial and Bayesian confidence intervals
library(LearnBayes) # For defining priors
library(ggpubr) # Assistance with graphics
library(GGally)# additional plotting functions
library(ggh4x) # additional plotting functions
library(gridExtra) # Combining plots generated in base R
library(lattice) # For Q-Q plots
library(tidyverse) # to enable 'tidy' collection of packages, including dplyr, ggplot2, purrr, forcats, readr
library(splines)
library(sjstats) # For Spearman's rank with boostrap 95% CI
```

## 1.3 Read in data and label
Read in the csv files "pnaat_desc_study" and "pnaat_desc" and prepare for descriptive statistics and meta-analysis.

### 1.3.1 Load and prepare study level data 
```{r message=FALSE, warning=FALSE}

meta_study <- read_csv("pnaat_desc_study.csv", col_types =cols(
  wbgroup = col_factor(levels= c("High income","Upper-middle income", 
                                 "Lower-middle income","Low income"),
                                              ordered=TRUE),
  country = col_factor(),
  num_cohort = col_factor(),
  num_test = col_factor(),
  pubstat = col_factor(levels= c("Peer-reviewed and published",
                                 "Peer-reviewed pre-print",
                                 "Non-peer reviewed pre-print"),
                                              ordered=TRUE),
  quality = col_factor()))

meta_study <- meta_study %>% mutate (n_test = fct_relevel(
num_test,"1","2","3","5-8"))
meta_study <- meta_study %>% mutate (n_cohort = fct_relevel(
num_cohort, "1","2","3-5"))
```


### 1.3.2 Load and prepare test-evaluation level data 
```{r message=FALSE, warning=FALSE}
# Load test evaluation level data and define variables
metadata <- read_csv ("pnaat_desc.csv", col_types = cols(
  wbgroup = col_factor(),
  country = col_factor(),
  pubstat = col_factor(levels= c("Peer-reviewed and published",
                                 "Peer-reviewed pre-print",
                                 "Non-peer reviewed pre-print"),
                                              ordered=TRUE),
  pool_size_gp = col_factor(levels=c("2","4 to 7", "8 to 15","16 to 31",
                                     "32+"),ordered=TRUE),
  symptoms = col_factor(levels=c("Asymptomatic","Mixed","Symptomatic")),
  naat = col_factor(levels=c("RT-PCR",
                         "Digital RT-PCR", "TMA", "Cartridge-based RT-PCR")),
  sample_pool = col_factor(),
  sample = col_factor(),
  pool_type = col_factor(),
  quality = col_factor(),
  modified_protocol = col_factor(),
  modint = col_factor(levels=c("lower","standard","higher")),
  pnaat = col_factor(),
  targets_for_pos = col_factor(levels=c("1 of 1", "1 of 2", "1 of 3",
                                        "2 of 2","2 of 3")),
  target = col_factor(levels=c("E","E, N, RdRp","E, Orf1ab","E, RdRp", 
                               "N", "N, Orf1ab","N, Orf1ab, S",
                               "N1, N2","N1, N3","Orf1ab")),
  storage = col_factor(),
  ref_std_same_sample = col_logical(),
  refstd_same_assay = col_logical(),
  refstd_same_time = col_logical(),
  refst_same_cutoff = col_logical(),
  regulatory_status = col_factor(),
  index_assay = col_factor(),
  refstd_assay = col_factor()))

# Transform variables for further analysis  
metadata <- metadata %>% mutate(log2p = log(pool_size,2))
metadata <- metadata %>% mutate(log2lod = log(lod,2))
metadata <- metadata %>% mutate(tma = if_else(naat=="TMA",1,0))
metadata <- metadata %>% mutate(rtpcr = if_else(naat=="RT-PCR",1,0))
metadata <- metadata %>% mutate(cbpcr = if_else(naat=="Cartridge-based RT-PCR",1,0))
metadata <- metadata %>% mutate(ddpcr = if_else(naat=="Digital RT-PCR",1,0))
metadata <- metadata %>% mutate(multitube = if_else(
                                    sample_pool=="swab multitube",1,0))
metadata <- metadata %>% mutate(swabrna = if_else(
                                    sample_pool =="swab extracted RNA",1,0))
metadata <- metadata %>% mutate(salivadirect = if_else(
  sample_pool=="saliva direct",1,0))
metadata <- metadata %>% mutate(salivarna = if_else(
  sample_pool=="saliva extracted RNA",1,0))
metadata <- metadata %>% mutate(swabmedia = if_else(
  sample_pool=="swab media",1,0))
metadata <- metadata %>% mutate(rna = if_else(
  pool_type=="RNA",1,0))
```

### 1.3.3 Load and prepare cohort level data
```{r message=FALSE, warning=FALSE}

# Create cohort level data
meta_cohort <- metadata %>% 
  group_by(cohort_id,symptoms,quality) %>% 
  summarise(maxparticipant = max(totalsamples), 
            maxdisease = max(disease_p),
            maxno_disease=max(disease_n), 
            maxweak_pos = max(weak_pos))
meta_cohort <- meta_cohort %>% mutate(positivity = maxdisease/maxparticipant*100)
```

### 1.3.4 Label data
```{r message=FALSE, warning=FALSE}

meta_study <- meta_study %>% var_labels (
  study_id = "Number of studies",
  wbgroup = "Country income level classification (World Bank 2020)",
  pubstat = "Publication and peer-review status",
  n_cohort = "Number of cohorts per study",
  n_test = "Number of tests per study")

meta_cohort <- meta_cohort %>% var_labels (
  cohort_id = "Number of cohorts",
  maxparticipant = "Total participants tested (n)",
  maxdisease = "Total participants with disease (positives) (n)",
  maxno_disease = "Total participants without disease (negatives) (n)",
  maxweak_pos = "% Positives with low viral load per cohort",
  positivity = "% Test positivity per cohort",
  symptoms = "Symptom status of cohort")

metadata <- metadata %>% var_labels(
  study_id = "Number of studies",
  wbgroup = "Country income level classification (World Bank 2020)",
  pubstat = "Publication and peer-review status",
  cohort_id = "Cohorts",
  cohort = "Cohorts within study",
  t_p = "True positives",
  f_p = "False positives",
  t_n = "True negatives",
  f_n = "False negatives",
  eval_id = "Number of test evaluations",
  disease_p = "Infected with SARS-CoV-2",
  disease_n = "Not infected with SARS-CoV-2",
  totalsamples = "Total participants",
  pnaat = "pNAAT design",
  pool_size = "Pool size (n)",
  pool_size_gp = "Pool size",
  symptoms = "Symptom status",
  naat = "Test technology",
  sample_pool = "Sample type and pooling method",
  sample = "Sample type",
  pool_type = "Pooling method",
  weak_pos = "% Weak positives (low VL)",
  multipos = "% Pools containing >1 positive sample",
  quality = "Eligibility for meta-analysis",
  positivity_rate = "% Test positivity ",
  lod = "Limit of detection (copies per mL)",
  targets_for_pos = "Number of targets for positive in index pool test",
  target = "Gene targets for index test",
  num_target = "Number of targets assessed",
  modified_protocol = "Modified from IFU or protocol",
  modified_interpret = "Modified interpretation",
  ref_std_same_sample = "Reference standard based on same sample",
  refstd_same_assay = "Reference standard based on same NAAT assay",
  refstd_same_time = "Index test performed at same time as reference standard",
  refst_same_cutoff = "Reference standard uses same Cq cut-off",
  regulatory_status = "Index test regulatory status",
  storage = "Storage before index test",
  disease35_p = "Infected with SARS-CoV-2 by cut-off Cq 35",
  disease35_n = "Not infected with SARS-CoV-2 by cut-off Cq 35",
  t35_p = "True positives for cut-off of Cq 35",
  f35_p = "False positives for cut-off of Cq 35",
  t35_n = "True negatives for cut-off of Cq 35",
  f35_n = "False negatives for cut-off of Cq 35",
  index_assay = "Index test brand",
  refstd_assay = "Reference standard brand")
```

### 1.3.5 Prepare datasets for metaanalysis
Reshape the 'metadata' tibble (created above) for bivariate binomial meta-analysis. The new tibble called 'Y' incorporates:

* One line each for data needed for sensitivity (diseased and true positives) and specificity (not diseased and true negatives) within each test evaluation,
* Dummy variables indicating rows referring to sensitivity or specificity
* Data for all other variables duplicated for sensitivity and specificity

```{r message=FALSE, warning=FALSE}

# convert metadata to dataframe for glmer compatibility
ma2 <- as.data.frame(metadata)

# transform covariates of proportions by folded square root (sQRT(x)-SQRT(1-x))
ma2 <- ma2 %>% mutate(weak_posfold = weak_pos^(1/2)-(1-weak_pos)^(1/2))
ma2 <- ma2 %>% mutate(positivity_ratefold = positivity_rate^(1/2)-(1-positivity_rate)^(1/2))
ma2 <- ma2 %>% mutate(multiposfold = multipos^(1/2)-(1-multipos)^(1/2))


# Create additional variables and reshape for bivariate analysis

ma2$n1 <- ma2$t_p + ma2$f_n # define number with disease
ma2$n0 <- ma2$t_n + ma2$f_p # define number without disease
ma2$true1 <- ma2$t_p # define true positives
ma2$true0 <- ma2$t_n # define true negatives
ma2$testeval <- 1:73 #give unique study id
ma2 <- ma2 %>% slice_head(n=73)

Y1 <- reshape(ma2, direction="long", 
               varying=list(c("n1","n0"), c("true1","true0")),
               timevar="sens",times=c(1,0),v.names=c("n","true"))

Y1 <- Y1 %>% var_labels(
  n = "Number by reference standard",
  true = "Number by index test")
Y1 = Y1[order(Y1$study),]
Y1$spec <- 1-Y1$sens
Y1se <- Y1 %>% filter(sens==1)
Y1se$naat <- dplyr::recode(Y1se$naat, "Cartridge-based RT-PCR" = "RT-PCR")
Y1se$naat <- forcats::fct_relevel(Y1se$naat,"RT-PCR")
Y1se$naat = relevel(Y1se$naat, ref="RT-PCR")


# Bivariate model datasets
Y1mp <- Y1 %>% filter(pnaat=="Minipool")  # for minipool (all sizes) #
Y1mp$naat <- dplyr::recode(Y1mp$naat, "Digital RT-PCR" = 2)
Y1mp$naat <- dplyr::recode(Y1mp$naat, "TMA" = 3)
Y1mp <- Y1mp %>% mutate(outcome = true/n)
y1mat <- Y1 %>% filter(pnaat=="Matrix")  # for matrix #
y1com <- Y1 %>% filter(pnaat=="Combinatorial")  # for combinatorial #

# Univariate model datasets
y1semp <- Y1se %>% filter(pnaat=="Minipool")  # for minipool (all sizes) #
y1semat <- Y1se %>% filter(pnaat=="Matrix")  # for matrix #
y1secom <- Y1se %>% filter(pnaat=="Combinatorial")  # for combinatorial

# Further data labeling and transformations
y1semp <- y1semp %>% var_labels(
  naat = "NAAT type",
  reg = "Regulatory approved test",
  weak_posfold = "Positives with low viral load (fsr)",
  multiposfold = "Pools with >1 positive sample (fsr)",
  positivity_ratefold="Test positivity rate (fsr)",
  log2p = "Log 2 pool size",
  log2lod = "Log 2 limit of detection (copies/mL)",
  modified_interpret = "Modified pool test cut-off",
  modified_protocol = "Modified test protocol")
y1semp <- y1semp %>% mutate (modified_protocol=as.factor(modified_protocol))
y1semp<- y1semp %>% mutate(reg = as.factor(reg))
y1semp<- y1semp %>% mutate(sensitivity = t_p/disease_p)

# Grand-mean centre all continuous variables
gmc2 <- function(x) {
    xcenter = mean(x)
    x - xcenter
}

y1semp <- y1semp %>% mutate(across(c(weak_posfold, positivity_ratefold, multiposfold, modified_interpret, log2lod, log2p, pool_size, weak_pos), ~gmc2(.x), "{.col}"))
```

# 2. Descriptive Statistics

## 2.1 Table 1 Description of studies
Generate Table 1.
```{r message=FALSE, warning=FALSE}

# Select variables for each sub-table
meta_top <- meta_study %>% dplyr::select(study_id, wbgroup,pubstat,n_cohort, n_test, quality)

meta_mid <- meta_cohort %>% dplyr::select(cohort_id, maxparticipant, maxdisease,
                                   maxno_disease, positivity,
                                   maxweak_pos, symptoms, quality)

meta_low <- metadata %>% dplyr::select(eval_id, pnaat, pool_size_gp, 
                                       multipos, naat,
                                sample, pool_type, index_assay,
                                regulatory_status, lod, targets_for_pos,
                                target, refstd_same_time, storage,
                                ref_std_same_sample, refstd_same_assay,
                                refst_same_cutoff, quality)

# Create sub-tables
t1<- tbl_summary(meta_top, by=quality, statistic = list(
  all_continuous() ~ "{median} ({p25} to {p75})", 
  study_id ~"{n_distinct}"))  %>% add_overall() %>%   
  modify_header(update = list(stat_0 ~ "**All**" , 
                              stat_1 ~ "**Single-gate**", 
                              stat_2 ~ "**Two-gate**"))
t2<- tbl_summary(meta_mid, by=quality, statistic = list(
  all_continuous() ~ "{median} ({p25} to {p75})", 
  cohort_id ~"{n_distinct}", 
  maxparticipant ~"{sum}", 
  maxdisease ~"{sum}", 
  maxno_disease ~"{sum}")) %>%  add_overall()

t3 <- tbl_summary(meta_low, by=quality, statistic = list(
  all_continuous() ~ "{median} ({p25} to {p75})", 
  eval_id ~"{n_distinct}"))  %>% add_overall()

# Stack the sub-tables into combined final table
stacked <- tbl_stack(list(t1,t2,t3)) %>% modify_spanning_header(
  c("stat_1", "stat_2") ~ "**Eligible for primary meta-analysis**") %>%
  modify_footnote(update = all_stat_cols() ~ "median (IQR) or n (%)")

stacked <- stacked %>% as_gt() %>% fmt_markdown(columns = TRUE) %>%
  gt::tab_source_note(gt::md("**LDT:** laboratory developed test; **pNAAT:** pooled nucleic acid amplification test; **RT-PCR:** reverse-transcription polymerase chain reaction; **TMA:** transcription mediated amplification;"))%>%
  tab_row_group(
    "Test evaluations", rows=30:114)  %>% tab_row_group(
    "Cohorts", rows=20:29)  %>% tab_row_group(
    "Studies", rows=1:19) %>% opt_table_font(
      font= google_font("Source Sans Pro")) %>% tab_options(
      row_group.background.color = "#CFD7E4", row_group.font.weight = "bold",
      table_body.hlines.color ="black",
      row_group.border.bottom.color = "black",
       row_group.border.bottom.width = px(1),
       row_group.border.top.width = px(1),
        heading.border.bottom.width = px(1),
        heading.border.bottom.color = "black",
        row_group.border.top.color = "black",
       footnotes.border.bottom.color = "black",
       footnotes.border.bottom.width = px(1),
       column_labels.border.top.color = "black",
       column_labels.border.top.width = px(1),
       table_body.border.top.color="black",
       table_body.border.bottom.color="black",
       table_body.border.top.width =px(1),
       table_body.border.bottom.width=px(1),
      source_notes.border.bottom.width = px(1),
      source_notes.border.bottom.color ="black",
       table.font.size = px(12)) 
stacked
```


# 3. Review of data

## 3.1 Asssessment of heterogeneity

### 3.1.1 Visual inspection of paired forest plots
Visual inspection of paired forest plots for all evaluations suggests:

* No heterogeneity in results for *combinatorial* or *matrix* pNAAT designs as very small number of eligible studies. Sensitivity and specificity likely to be best summarised by binomial exact estimates and confidence intervals. 
* Substantial heterogeneity in sensitivity seen in *minipool* designs but specificity approaching 100% across all evaluations.

```{r message=FALSE, warning=FALSE}

# Derive exact binomial confidence intervals for all studies
uni <- binom.confint(Y1$true, Y1$n, conf.level = 0.95, methods = "exact")
uni <- uni %>% dplyr::select(mean,lower,upper)
uniex <- uni %>% dplyr::rename(c(est=mean, lci =lower, uci =upper))
Y1plus <- cbind(Y1,uniex)
Y1plus <- Y1plus  %>% dplyr::rename (Study=test_eval_id )
Y1plus <- Y1plus %>% dplyr::mutate (estse = sens*est)
Y1plus <- Y1plus %>% mutate(Study= fct_reorder(Study, estse))
Y1plus$sens <- recode_factor(Y1plus$sens, '1' = "Sensitivity", '0' = "Specificity")

set_theme(theme_classic2)
fp = ggplot(Y1plus, aes(x = Study,y = est, ymin = lci, ymax = uci))+
    geom_pointrange(aes(ymin= lci, ymax= uci), shape = 15, size = 0.1,
                    color = "black", fill="white", width=0.1,cex=1, )+
    coord_flip()+
    xlab('Study')+ 
    scale_y_continuous("Sensitivity (95% Confidence Interval)",
                       breaks=seq(0,1,0.1))+
    facet_grid (pnaat~sens, drop=TRUE, scales="free_y")+
    force_panelsizes(rows = c(10,0.3,0.5), cols=c(3,3)) +
    theme(axis.text=element_text(size=5),
        axis.title=element_text(size=6, face="bold"),
        strip.text.x = element_text(angle=0, size = 6),
         panel.grid.major.y = element_blank())+
  theme(strip.text.y = element_text(angle=0, size = 6))
fp
```

### 3.1.2 Formally test heterogeneity
We used the *madad* function of the *mada* package to test for heterogeneity in sensitivity and specificity (Ho: no heterogeneity, H1: heterogeneity)
```{r message=FALSE, warning=FALSE}

# Use 'madad' function 
confmatrix <- metadata %>% dplyr::select(test_eval_id,t_p,f_n,f_p,t_n, pool_size_gp, pool_size, pnaat, naat, sample, pool_type)
confmatrix <- confmatrix %>% rename(c(Study = test_eval_id, TP=t_p, FN=f_n, FP=f_p, TN=t_n))
hg <- madad(confmatrix)
heterogeneity_test_sensitivity <- c(hg[[c(4,1)]],hg[[c(4,2)]],hg[[c(4,3)]])
heterogeneity_test_specificity <- c(hg[[c(5,1)]],hg[[c(5,2)]],hg[[c(5,3)]])
hgall <- rbind(heterogeneity_test_sensitivity,heterogeneity_test_specificity)
Outcome <- c("Sensitivity","Specificity")
hgall2 <-cbind(Outcome,hgall)
hgall2 <- as_tibble(hgall2)
hgall2 <- hgall2 %>% rename (p = V4)
hgall2 <- hgall2 %>% rename (chi2 = "X-squared")
hgall2$p <- as.numeric (hgall2$p)
hgall2$chi2 <- as.numeric (hgall2$chi2)
hgall2 <- hgall2 %>% mutate_if(is.numeric, round, 4)
gt_hgall <- gt(data = hgall2)
gt_hgall %>% tab_header(title = "Test for equality of sensitivities and specificities")
```

## 3.2 Check for threshold effects
We investigated a threshold effect: i.e, a trade-off of sensitivity and specificity as positivity threshold is varied.

### 3.2.1 Descriptive plots
Descriptive plots of observed and estimated sensitivity and 1-specificity (FPR) in ROC space show an apparent lack of association, given specificity is ~100% in all studies. While the pool-test stage of a pooling method can result in 'FP' pools, subsequent re-testing of samples within these pools, or analoguous algorithmic deconvoluting, largely excludes FP individual sample results.

```{r message=FALSE, warning=FALSE}
# Descriptive plots
p1cor <- ggplot (corrfprse, aes(x= fpr, y=point, size=n))+
  geom_point(alpha=0.1, colour ="blue")+
  ylim(0,1)+
  xlim(0,1)+
  geom_abline(intercept = 0, slope = 1)+
  labs(y= "Sensitivity", x = "1-Specificity")+
  theme(legend.position = "none")

p2cor <- plotdata(confmatrix2, two.by.two=TRUE, alpha.p=0.1, max.size=15)+
  geom_smooth(method=lm , alpha = 0.3, color="#6699cc", fill="#6699cc", se=TRUE)+
   theme (panel.grid.minor=element_blank())+
   theme (legend.position = "none")+
  scale_x_continuous("1-specificity", limits = c(-0.0001, 0.0015))+
  scale_y_continuous ("Sensitivity", breaks=seq(0,1,0.1), limits = c(0,1))

ggarrange(p1cor, p2cor, ncol=2)
```
### 3.2.2 Correlation of Sensitivity and FPR
We used the *crosstable_statistics* function of the *sjtools* package to derive a Spearman's rank  correlation of sensitivity and FPR, weighted by overall number tested (n).

```{r message=FALSE, warning=FALSE}
cts<- crosstable_statistics(data=corrfprse, x1=fpr, x2=point, statistics="spearman", weights= corrfprse$totalsamples)
cts2 <- c(cts$estimate, cts$p.value)
z = -0.862 + sqrt (0.743-(2.404*log(cts$p.value)))
int = 1.96*(cts$estimate/z)
lci = cts$estimate + int
uci = cts$estimate - int
cts2 <- c(cts$estimate, lci ,uci, cts$p.value)
param <- c("rho","lci","uci","p" )
cts3 <- cbind(param,cts2)
as.tibble(cts3)
```
### 3.2.3 Reitsma approach for summary point in ROC space
We used the *reitsma* function from the *mada* package to attempt to fit a summary point and predictive interval in ROC space for minipool pNAAT design only.
```{r message=FALSE, warning=FALSE}
confmatrix2 <- confmatrix %>% mutate(n1 = TP+FN)
confmatrix2 <- confmatrix2 %>% mutate(n2 = FP+TN)
confmatrix2 <- confmatrix2 %>% mutate(Study =as.character(Study))

reit<- reitsma(confmatrix2,TP="TP", FN="FN", FP="FP", TN="TN",alphasens = 1, alphafpr = 1,correction = 0.5, correction.control = "all",method = "reml")
plot(reit, extrapolate = FALSE, plotsumm = TRUE, level = 0.95, 
     ylim = c(0,1), xlim = c(0,0.01), pch = 1, sroclty = 1, sroclwd = 1, 
     predict = TRUE, predlty = 3, predlwd = 1)
summary(reit)
```

### 3.2.4 Bayesian approach for summary point in ROC space
We used the *metadiag* function from the *bamdit* package to take a Bayesian approach to fitting a summary point and posterior predictive intervals in ROC space for minipool pNAAT design only.
```{r message=FALSE, warning=FALSE}
# Filter to obtain only minipool studies


result <- metadiag(confmatrix2, two.by.two=TRUE, re = "normal", re.model = "DS", link = "logit", sd.Fisher.rho = 1.7, nr.burnin = 1000, nr.iterations = 5000, nr.chains = 4, r2jags = TRUE)
plot(result, level = c(0.5,0.75, 0.95), parametric.smooth = TRUE, limits.x = c(0,0.01))
plotsesp(result)
```

## 3.3 Data structure for random effects
We sought to resolve two issues before proceeding to summary effects:

1) *Is a bivariate random-effects model most suitable?* Review of the paired forest plots indicates substantial between-study variance in sensitivity but specificity approached 1.00 in all studies. As such a bivariate random-effects model may not converge or produce singular fits.
In add
2) *Should random-effects be explored with 2 or 3 levels?* The review identified test-evaluations within cohorts, within studies. Pragmatically we considered cohorts as the highest level of clustering. However, we considered whether test-evaluation alone (2-level) or test-evaluation nested within cohort (3-level) should be used,

To explore these options we used the glmer function in "lme4" to fit integer only models to the largest planned synthesis (all minipools combined, n = 69 test evaluations, n =37 cohorts)

* Model 1: A bivariate binomial random-effects model with an unstructured covariance matrix: random-effects considered for both sensitivity and specificity with unknown correlation (to confirm random-effects for specificity were not required)
* Model 2: A bivariate binomial random-effects model with zero covariance matrix: random-effects considered for both sensitivity and specificity but with no correlation between 
* Model 3: A bivariate binomial partial random-effects model: random-effects are considered for sensitivity but not for susceptibility.
* Model 4: univariate binomial random-effects model (sensitivity only)
4a) 3-level model with test-evaluations nested within cohorts
4b) 2-level model with test-evaluations as highest clustering.

### 3.3.1 model 1 bivariate binomial random-effects with unstructured covariance matrix
Use glmer to fit an integer only bivariate binomial mixed (random-effects) meta-analysis with an unstructured covariance matrix. We observe
* Confirms substantial between-studies variance among mini-pool designs
* Correlation of fixed effects is confirmed to be low (~0.15).
* Covariance in random effects = 1 suggesting over-fitting and need to reduce model complexity
* Overall suggests a similar model with either a zero correlation covariance matrix (model 2 below) or considering no random-effects in specificity (model 3 below) more appropriate.

```{r message=FALSE, warning=FALSE}

ymp_mod1 <- glmer (formula= cbind(true,n-true)~0+sens+spec+(0+sens+spec|testeval),
                    data = Y1mp,family=binomial,nAGQ=1,verbose=0)
ymp_mod1_sum <- summary(ymp_mod1)
ymp_mod1_sum
co1 <- ymp_mod1_sum$coeff[1,1]
ci1 <- confint(ymp_mod1, level = 0.95,method = "boot",boot.type = "perc", nsim=200)
plogis(co1)
plogis(ci1)
```

### 3.3.2 model 2 bivariate binomial random-effects with zero covariance matrix
Use glmer to fit an integer only bivariate binomial multi-level (random-effects) meta-analysis with a zero covariance matrix. We observe:

* The estimates for sensitivity (0.941) and specificity (~1.00) are similar to model 1.
* However, the between-studies variance is limited to sensitivity, with between-studies variance in specificity ~0 which is more consistent with observations.
*  A model considering no random-effects in specificity (model 3 below) or a univariate model focused on sensitivity (model 4 below) may be more appropriate.

```{r message=FALSE, warning=FALSE}

ymp_mod2 <- glmer (formula= cbind(true,n-true)~0+sens+spec+(0+sens|testeval), Y1mp, family=binomial,nAGQ=1,verbose=0) 
ymp_mod2_sum <- summary(ymp_mod2)
ymp_mod2_sum
co2 <- ymp_mod2_sum$coeff[1,1]
ci2 <- confint(ymp_mod2, level = 0.95,method = "boot",boot.type = "perc", nsim=200)
plogis(co2)
plogis(ci2)
```



### 3.3.3 Model 3: Bivariate binomial partial random effects model
Observations:

* Estimated sensitivity and specificity are as in model 1.
* The between-studies variance for sensitivity is ~ the same in model 2.
* BIC is slightly better than model 1 and 2 suggesting a more parsimonious model
* Confirms a model with no random-effects in specificity appropriate. 
* Since specificity approaches unity in all studies and cohorts, a univariate model focused on sensitivity (model 4 below) may be more appropriate.
```{r message=FALSE, warning=FALSE}

ymp_mod3 <- glmer (formula= cbind(true,n-true)~0+sens+spec+(0+sens|testeval),
                    data = Y1mp,family=binomial,nAGQ=1,verbose=0)
ymp_mod3_sum <- summary(ymp_mod3)
ymp_mod3_sum
co3 <- ymp_mod3_sum$coeff[1,1]
ci3 <- confint(ymp_mod3, level = 0.95,method = "boot",boot.type = "perc", nsim=200)
plogis(co3)
plogis(ci3)
```


### 3.3.4 model 4 Sensitivity only model
Use glmer to fit an integer only univariate (outcome  is sensitivity only) binomial multi-level (random-effects) meta-analysis
Observations

* Depending on method used for ICC calculation, around 35-55% of total variation in sensitivity occurs between test-evaluations.
* A univariate random-effects (glmm) model with test-evaluation at level 2 captures between-study variation efficiently.
* A univariate random-effects (glmm) model with test-evaluation (level 2) nested within study cohorts (level 3) is also suitable but is likely to result in over-fitting.

#### model 4a study as level 2
```{r message=FALSE, warning=FALSE}
set.seed(99)
ysemp2 <- glmer (formula= cbind(true,n-true)~ 1+(1|testeval),
                    data = y1semp,family=binomial, nAGQ=1,verbose=0) 
ysemp2_sum <- summary(ysemp2)
ysemp2_sum
co4a <- ysemp2_sum$coeff[1,1]
ci4a <- confint(ysemp2, level = 0.95,method = "boot",boot.type = "perc", nsim=200)
plogis(co4a)
plogis(ci4a)
```

#### Model 4b Nested (studies nested within cohorts)
```{r message=FALSE, warning=FALSE}

ysemp3 <- glmer (formula= cbind(true,n-true)~ 1+(1|testeval/cohort_id),
                    data = y1semp,family=binomial, nAGQ=1,verbose=0) 
ysemp3_sum <- summary(ysemp3)
ysemp3_sum
co3c <- ysemp3_sum$coeff[1,1]
ci3c <- confint(ysemp3, level = 0.95,method = "boot",boot.type = "perc", nsim=200)
plogis(co3c)
plogis(ci3c)
```

### 3.3.5 Summarising results for minipool
Overall we suggest the following pre-planned schedule for model fits starting at stage 1 and progressing (stage 1 to 4 in order) if overfitting, non-convergence or other model-fit issues
1st stage: Bivariate binomial partial random-effects model
2nd stage: Univariate binomial random-effects model (glmm in lme4)
3rd stage: Univariate binomial fixed-effects model (glm in lme4)
4th stage: Collate confusion matrix numbers and perform binomial.test with binomial exact and/or Bayesian confidence intervals.
```{r message=FALSE, warning=FALSE}
#### Summarising results
mptable <- tab_model (ymp_mod2, ymp_mod3, ysemp2, ysemp3, transform=NULL,
                           show.p=FALSE, collapse.ci = TRUE,  show.reflvl = TRUE, show.icc = FALSE, show.obs = FALSE, show.r2 = FALSE, show.loglik = TRUE, show.aic = TRUE, pred.labels=c("Intercept","Weak positives (fsqroot)", "NAAT: digital PCR","NAAT: TMA", "log 2 of pool size","Sample type: saliva","Modified test protocol", "Modified pool test cut-off", "Regulatory approval: yes"),
  dv.labels=c("Bivariate, zero covariance","Bivariate, partial random RE" ,"Univariate 2-level", "Univariate 3-level"))

mptable

```



# 4. Summary estimates of test accuracy

## 4.1 Summary by pNAAT design

### 4.1.1 Combinatorial
Only a single study was identified (Chakraborty 2020 [A-C]) which employed a combinatorial pooled test approach to a representative set of specimens. Three slight variants of the approach were assessed on three cohorts. Since there were 0 FNs and only 1 FP across the three cohorts we decided to sum TP,FP,TN, and FN across the cohorts and to estimate sensitivity and specificity using binomial exact method (and later Bayesian inference - see section 8).

#### Estimate sens and spec (and 95% CIs) using the binomial exact method
```{r message=FALSE, warning=FALSE}

ycomsens <-c(binom.test(25,25)$estimate, binom.test(25,25)$conf.int)
ycomspec <-c(binom.test(1765,1766)$estimate, binom.test(1765,1766)$conf.int)
cosum <- rbind(ycomsens,ycomspec)
rowlab <- c("Sensitivity","specificity")
comb_summary <-cbind(rowlab,cosum)
comb<- as.tibble(comb_summary)
comb<- comb %>% rename(Parameter = rowlab, estimate ="probability of success", "lower 95% CI"=V3, "upper 95% CI"=V4)
comb$estimate = as.numeric (comb$estimate)
comb$`lower 95% CI` = as.numeric (comb$`lower 95% CI`)
comb$`upper 95% CI` = as.numeric (comb$`upper 95% CI`)
combgt <- gt(comb)
combgt2 <- combgt %>% fmt_number(columns = c(estimate, "lower 95% CI", "upper 95% CI"),decimals = 3)
combgt2
```

### 4.1.2 Matrix
Only a single study was identified (Ben-Ami 2020 [B]) which employed a matrix pooled test approach to a representative set of specimens.

#### Estimate sens and spec (and 95% CIs) using the binomial exact method
```{r message=FALSE, warning=FALSE}

ymatsens <-c(binom.test(3,3)$estimate, binom.test(3,3)$conf.int)
ymatspec <-c(binom.test(72,72)$estimate, binom.test(72,72)$conf.int)
matsum <- rbind(ymatsens,ymatspec)
matsummary <-cbind(rowlab,matsum)
mat<- as.tibble(matsummary)
mat<- mat %>% rename(Parameter = rowlab, estimate ="probability of success", "lower 95% CI"=V3, "upper 95% CI"=V4)
mat$estimate = as.numeric (mat$estimate)
mat$`lower 95% CI` = as.numeric (mat$`lower 95% CI`)
mat$`upper 95% CI` = as.numeric (mat$`upper 95% CI`)
matgt <- gt(mat)
matgt2 <- matgt %>% fmt_number(columns = c(estimate, "lower 95% CI", "upper 95% CI"),decimals = 3)
matgt2
```


### 4.1.3 Minipool
The review identified 69 evaluations of minipool tests across 37 cohorts. 
A bivariate binomial partial random-effects model (converged considering only random-effects in sensitivity)
```{r message=FALSE, warning=FALSE}
set.seed(111)
ymp_modfinal <- glmer (formula= cbind(true,n-true)~0+sens+spec+(0+sens|testeval),
                    data = Y1mp,family=binomial,nAGQ=1,verbose=0)
ymp_modfinal_sum <- summary(ymp_modfinal)
ymp_modfinal_sum
co3 <- ymp_modfinal_sum$coeff[1,1]
ci3 <- confint(ymp_modfinal, level = 0.95,method = "boot",boot.type = "perc", nsim=200)
plogis(co3)
plogis(ci3)
```

# 5 Sub-group analyses
We summarise test accuracy for the following sub-groups of minipool pNAAT:

* 5.1 Pool size groups (only)
* 5.2 NAAT type and Pool size groups
* 5.3 Symptom status and Pool size groups
* 5.4 Sample type and Pool size groups
* 5.5 Pooling method and Pool size groups

## 5.1 Pool size groups

### 5.1.1 Minipool of size 2 
Only 3 test-evaluations (from 2 studies) looked at minipool sizes of 2.
stage 1: A partial random effects model (mp2a) was singular.
stage 2: Univariate random effects model (mp2b) was singular
stage 3: Univariate fixed effects model (mp2c) for sensitivity
Stage 4: Binomial test with binomial exact 95% CI fit for specificity

```{r message=FALSE, warning=FALSE}
#### Stage 1 model
ymp2 <- Y1mp %>% filter(pool_size_gp=="2")
ymp2se <- y1semp %>% filter(pool_size_gp=="2")
mp2a <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ymp2,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp2a_sum <- summary(mp2a)

#### Stage 2 model (sensitivity only)
mp2b <- glmer (formula= cbind(true,n-true)~ 1+(1|testeval), data = ymp2se, family=binomial,nAGQ=1,verbose=0) # fixed + random model
mp2b_sum <- summary(mp2b)

#### Stage 3 model (sensitivity only, fixed)
mp2c <- glm (formula= cbind(true,n-true)~ 1, data = ymp2se, family=binomial) # fixed + random model
mp2c_sum <- summary(mp2c)
set.seed (212)
mp2c_ci <- confint (mp2c, level=0.99, method="boot", quiet=TRUE, nsim=200)
mp2c_ci <- plogis(mp2c_ci)
mp2c_ci <- as.tibble(mp2c_ci)
est2 <- plogis (mp2c_sum$coefficients [1,1])
mp2se<- cbind(estimate = est2, lci = mp2c_ci[1,1], uci=mp2c_ci[2,1])

#### Stage 4 model specificity only
yp2spest  <- binom.test(264,264)$estimate
yp2spest <- as.tibble(yp2spest)
yp2spest <- yp2spest %>% rename (estimate = value)
yp2spci <- binom.test(264,264)$conf.int
yp2spci <- as.tibble(yp2spci)
yp2spec <- cbind(estimate = yp2spest[1,1], lci=yp2spci[1,1],uci=yp2spci[2,1])

#### Summary
yp2sum <- rbind(mp2se, yp2spec)
names(yp2sum) [2] <- "lower 99% CI"
names(yp2sum) [3] <- "upper 99% CI"
lab2sum <- c("Sensitivity","Specificity")
rowcat <- c("2", "2")
yp2sums <- cbind(rowcat, lab2sum,yp2sum)
yp2sums <- yp2sums %>% rename(parameter = lab2sum)
yp2sums
```


### 5.1.2 Minipool of size 4-7 
#### Stage 1 model
```{r message=FALSE, warning=FALSE}
ymp47 <- Y1mp %>% filter(pool_size_gp=="4 to 7")
ymp47se <- y1semp %>% filter(pool_size_gp=="4 to 7")
mp47a <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ymp47,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp47a_sum <- summary(mp47a)
mp47a_sum
isSingular(mp47a)
set.seed (212)
mp47a_ci <- confint (mp47a, level=0.99, method="boot", quiet=TRUE)

mp47ci <- as.tibble(mp47a_ci)
mp47est <- as.tibble(mp47a_sum$coefficients[1:2,1])

est47 <- plogis (mp47a_sum$coefficients[1:2,1])
ci47 <- plogis(mp47a_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("4-7","4-7")
summp47 <- cbind(rowcat, lab47,est47,ci47)
sum47 <- as.tibble(summp47)
sum47 <- sum47 %>% rename (parameter = lab47, estimate = est47, "lower 99% CI"=`0.5 %`, "upper 99% CI"=`99.5 %`)
sum47
```

### 5.1.3 Pool size 8 to 15

```{r message=FALSE, warning=FALSE}
#### Stage 1 model
ymp815 <- Y1mp %>% filter(pool_size_gp=="8 to 15")
ymp815se <- y1semp %>% filter(pool_size_gp=="8 to 15")
mp815a <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ymp815, family=binomial, 
nAGQ=1,verbose=0) 
mp815a_sum <- summary(mp815a)
mp815a_sum
isSingular(mp815a)
set.seed (212)
mp815a_ci <- confint (mp815a, level=0.99, method="boot", quiet=TRUE)
est815 <- plogis (mp815a_sum$coefficients[1:2,1])
ci815 <- plogis(mp815a_ci[2:3,1:2])
lab815 <- c("Sensitivity","Specificity")
sum815<- cbind(lab815,est815,ci815)
sum815 <- as.tibble(sum815)
sum815 <- sum815 %>% rename(parameter = lab815, estimate =est815, "lower 99% CI"=`0.5 %`, "upper 99% CI"=`99.5 %`)
rowcat <- c("8-15", "8-15")
sum815 <- cbind(rowcat, sum815)
sum815

```


### 5.1.4 Pool size 16 to 31
stage 1: A partial random effects model (mp16a) failed to converge
stage 2: Univariate random effects model (mp2b) was singular
stage 3: Univariate fixed effects model (mp2c) for sensitivity
Stage 4: Binomial test with binomial exact 95% CI fit for specificity

```{r message=FALSE, warning=FALSE}
#### Stage 1 model
ymp16 <- Y1mp %>% filter(pool_size_gp=="16 to 31")
ymp16se <- y1semp %>% filter(pool_size_gp=="16 to 31")
mp16a <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ymp16, family=binomial, 
nAGQ=1,verbose=0) 
mp16a_sum <- summary(mp16a)

#### Stage 2 model
mp16b <- glmer (formula= cbind(true,n-true)~ 1+(1|testeval), data = ymp16se, family=binomial,nAGQ=1,verbose=0)
mp16b_sum <- summary(mp16b)
set.seed (212)
mp16b_ci <- confint (mp16b, level=0.99, method="boot", quiet=TRUE, nsim=200)
est16 <- plogis (mp16b_sum$coefficients[1,1])
ci16 <- plogis(mp16b_ci[2,1:2])
sum16<- c(est16,ci16)
#### Stage 4 model (specificity only)
y16spec <-c(binom.test(6944,6944)$estimate, binom.test(6944,6944)$conf.int)

#### Summary 
y16sum <- rbind(sum16,y16spec)
y16sum <- as.tibble (y16sum)
y16sum<- y16sum %>% rename(estimate =V1 , "lower 99% CI"=`0.5 %`, "upper 99% CI"=`99.5 %`)
rowlab <- c("Sensitivity","Specificity")
rowcat <- c("16-31", "16-31")
y16sum <- cbind(rowcat,rowlab,y16sum)
y16sum<- y16sum %>% rename(parameter =rowlab)

y16sum
```



### 5.1.5 Pool size 32+
Only 1 study was included with a pool size 32+. We therefore summarised by binom.test and binomial exact CI
```{r message=FALSE, warning=FALSE}
ymp32 <- Y1mp %>% filter(pool_size_gp=="32+")
ymp32se <- y1semp %>% filter(pool_size_gp=="32+")
ymp32sens <-c(binom.test(26,26)$estimate, binom.test(26,26)$conf.int)
ymp32spec <-c(binom.test(422,422)$estimate, binom.test(422,422)$conf.int)
ymp32sum <- rbind(ymp32sens,ymp32spec)
rowlab <- c("Sensitivity","Specificity")
rowcat <- c("32+", "32+")
ymp32sum <-cbind(rowcat, rowlab,ymp32sum)
ymp32sum<- as.tibble(ymp32sum)
ymp32sum<- ymp32sum %>% rename(parameter = rowlab, estimate ="probability of success", "lower 99% CI"=V4, "upper 99% CI"=V5)
ymp32sum$estimate = as.numeric (ymp32sum$estimate)
ymp32sum$`lower 99% CI` = as.numeric (ymp32sum$`lower 99% CI`)
ymp32sum$`upper 99% CI` = as.numeric (ymp32sum$`upper 99% CI`)
ymp32sum
```
### 5.1.6 Summary table for pool sizes
```{r message=FALSE, warning=FALSE}
sums <- metadata %>% filter (pnaat == "Minipool") %>% group_by (pool_size_gp) %>% summarise(Studies =n_distinct(study_id), Cohorts=n_distinct(cohort_id), "Test evaluations" = n_distinct(test_eval_id), "Participants" =sum(totalsamples),"SARS-CoV-2+"=sum(disease_p), TP=sum(t_p),
                                                   FN=sum(f_n),FP=sum(f_p),TN=sum(t_n))
psum <- rbind(yp2sums, sum47, sum815, y16sum,ymp32sum)
psum <- psum %>% pivot_wider(names_from = parameter, values_from = c(estimate, `lower 99% CI`, `upper 99% CI`))
psum2 <- psum %>% select(-rowcat) %>% mutate_if(is.character,as.numeric)
psum2 <- cbind(sums,psum2)
psum3 <- as.tibble(psum2)
gtpssum <- gt(data = psum3) %>%
  tab_spanner(label = "Sensitivity",
    columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity")) %>%
  tab_spanner(label = "Specificity",
    columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity")) %>%
  cols_label(
    estimate_Specificity = html("Estimate"),
    "lower 99% CI_Specificity" = html("lower 99% CI"),
    "upper 99% CI_Specificity" = html("upper 99% CI"),
      estimate_Sensitivity = html("Estimate"),
    "lower 99% CI_Sensitivity" = html("lower 99% CI"),
    "upper 99% CI_Sensitivity" = html("upper 99% CI"),
    pool_size_gp = html ("Pool size")
  )%>%
 fmt_number(columns= c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), decimals=3) %>%
    tab_footnote(
    footnote = "Stage 1 estimate: bivariate binomial partial-random effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(2,3))) %>%
  tab_footnote(
    footnote = "Stage 2 estimate: univariate random-effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 4)) %>%
    tab_footnote(
    footnote = "Stage 3 estimate: univariate fixed-effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 1)) %>%
  tab_footnote(
    footnote = "Stage 4 estimate: binomial test and exact CI",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 5)) %>%
  tab_footnote(
    footnote = "Stage 4 estimate: binomial test and exact CI",
    locations = cells_body(columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(1,4:5))) %>%
cols_align(align = "left", columns = pool_size_gp) %>%
  tab_options(footnotes.marks=c("*","^","+",""))
gtpssum
```


### 5.1.7 Adding pool size to integer only random-effects model
```{r message=FALSE, warning=FALSE}
# All minipool test evaluations
mpsize1 <- glmer (formula= cbind(true,n-true)~1+log2p+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpsize1_sum <- summary(mpsize1)
mpsize1_sum

# Excluding single study with pool size 32+
mpsdata2 <- y1semp %>% filter(pool_size<20)
mpsize2 <- glmer (formula= cbind(true,n-true)~1+log2p+(1|testeval),
                 data = mpsdata,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpsize2_sum <- summary(mpsize2)
mpsize2_sum

lrtest(mpsize1, ysemp2)
```

## 5.2 NAAT type

### 5.2.1 data preparation
```{r message=FALSE, warning=FALSE}
ymprtpcr <- Y1mp %>% filter(naat2=="1")
ysemprtpcr<- y1semp %>% filter(naat2=="1")
ympddpcr <- Y1mp %>% filter(naat2=="2")
ysempddpcr<- y1semp %>% filter(naat2=="2")
ymptma <- Y1mp %>% filter(naat2=="3")
ysemptma<- y1semp %>% filter(naat2=="3")
```

### 5.2.2 RT-PCR
```{r message=FALSE, warning=FALSE}
# Stage 1 model: bivariate binomial partial random-effects
ymprtpcr <- ymprtpcr %>% filter(test_eval_id !="Anderson 2020 [B]")
mp_rtpcr <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ymprtpcr,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_rtpcr_sum<- summary(mp_rtpcr)
mp_rtpcr_sum
isSingular(mp_rtpcr)

set.seed (212)
mp_rtpcr_ci <- confint (mp_rtpcr, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_rtpcr <- plogis (mp_rtpcr_sum$coefficients[1:2,1])
ci_rtpcr <- plogis(mp_rtpcr_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("RT-PCR","RT-PCR")
sum_rtpcr <- cbind(rowcat, lab47,est_rtpcr,ci_rtpcr)
sum_rtpcr <- as.tibble(sum_rtpcr)
sum_rtpcr <- sum_rtpcr %>% rename (parameter = lab47, estimate = est_rtpcr, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_rtpcr
```
### 5.2.3 Digital PCR
Stage 1 model was singular
```{r message=FALSE, warning=FALSE}
# Stage 1 model: bivariate binomial partial random-effects
mp_ddpcr <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympddpcr,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_ddpcr_sum<- summary(mp_ddpcr)
mp_ddpcr_sum
isSingular(mp_ddpcr)

# Stage 2 model: univariate binomial random-effects
mp_ddpcrb <- glmer (formula= cbind(true,n-true)~0+sens+
(0+sens|testeval), data = ysempddpcr,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_ddpcrb_sum<- summary(mp_ddpcrb)
mp_ddpcrb_sum
isSingular(mp_ddpcrb)

# Stage 3 model: univariate binomial fixed-effects
mp_ddpcrc <- glm (formula= cbind(true,n-true)~0+sens, data = ysempddpcr,
family=binomial)
mp_ddpcrc_sum<- summary(mp_ddpcrc)
mp_ddpcrc_sum
mp_ddpcr_ci <- confint (mp_ddpcrc, level=0.99, method="boot", quiet=TRUE,nsim=200)

# Stage 4 model: binomial test for specificity
mp_ddpcr_spest <-binom.test(1259,1262)$estimate
mp_ddpcr_spci<- binom.test(1259,1262)$conf.int
mp_ddpcr_spci <- mp_ddpcr_spci[1:2]
est_ddpcr <- plogis (mp_ddpcrc_sum$coefficients[1,1])
ci_ddpcr <- plogis(mp_ddpcr_ci[1:2])
mp_ddpcr_ci <- rbind(ci_ddpcr, mp_ddpcr_spci)
mp_ddpcr_est <-rbind(mp_ddpcr_spest, est_ddpcr)
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Digital-PCR","Digital-PCR")
sum_ddpcr <- cbind(rowcat, lab47,mp_ddpcr_est,mp_ddpcr_ci)
sum_ddpcr <- as.tibble(sum_ddpcr)
sum_ddpcr <- sum_ddpcr %>% rename (parameter = lab47, estimate = `probability of success`, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_ddpcr
```

### 5.2.4 TMA
```{r message=FALSE, warning=FALSE}
# Stage 1 model: bivariate binomial partial random-effects
mp_tma <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ymptma,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_tma_sum<- summary(mp_tma)
mp_tma_sum
isSingular(mp_tma)
set.seed (212)
mp_tma_ci <- confint (mp_tma, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_tma <- plogis (mp_tma_sum$coefficients[1:2,1])
ci_tma <- plogis(mp_tma_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("TMA","TMA")
sum_tma <- cbind(rowcat, lab47,est_tma,ci_tma)
sum_tma <- as.tibble(sum_tma)
sum_tma <- sum_tma %>% rename (parameter = lab47, estimate = est_tma, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_tma
```

### 5.2.5 Cartridge-based PCR
```{r message=FALSE, warning=FALSE}
mp_cbpcr_sens <-c(binom.test(19,19)$estimate, binom.test(19,19)$conf.int)
mp_cbpcr_spec <-c(binom.test(281,281)$estimate, binom.test(281,281)$conf.int)
mp_cbpcr <-(rbind(mp_cbpcr_sens, mp_cbpcr_spec))
mp_cbpcr <- as.tibble(mp_cbpcr)
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Cartridge-based PCR","Cartridge-based PCR")
sum_cbpcr <- cbind(rowcat, lab47,mp_cbpcr)
sum_cbpcr <- as.tibble(sum_cbpcr)
sum_cbpcr <- sum_cbpcr %>% rename (parameter = lab47, estimate = `probability of success`, "lower 99% CI"=V2, "upper 99% CI" = V3)
sum_cbpcr
```
### 5.2.6 Summary table NAAT type
```{r message=FALSE, warning=FALSE}
sum_naat <- metadata %>% filter(pnaat=="Minipool") %>% group_by (naat) %>% summarise(Studies =n_distinct(study_id), Cohorts=n_distinct(cohort_id), "Test evaluations" = n_distinct(test_eval_id), "Participants" =sum(totalsamples),"SARS-CoV-2+"=sum(disease_p), TP=sum(t_p),                                                FN=sum(f_n),FP=sum(f_p),TN=sum(t_n))

naatsum <- rbind(sum_rtpcr, sum_ddpcr, sum_tma, sum_cbpcr)
naatsum <- naatsum %>% pivot_wider(names_from = parameter, values_from = c(estimate, `lower 99% CI`, `upper 99% CI`))
naatsum2 <- naatsum %>% select(-rowcat) %>% mutate_if(is.character,as.numeric)
naatsum2 <- cbind(sum_naat,naatsum2)
naatsum3 <- as.tibble(naatsum2)
gtnaatsum <- gt(data = naatsum3) %>%
  tab_spanner(label = "Sensitivity",
    columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity")) %>%
  tab_spanner(label = "Specificity",
    columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity")) %>%
  cols_label(
    estimate_Specificity = html("Estimate"),
    "lower 99% CI_Specificity" = html("lower 99% CI"),
    "upper 99% CI_Specificity" = html("upper 99% CI"),
      estimate_Sensitivity = html("Estimate"),
    "lower 99% CI_Sensitivity" = html("lower 99% CI"),
    "upper 99% CI_Sensitivity" = html("upper 99% CI"),
     naat = html ("NAAT type")
  )%>%
 fmt_number(columns= c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), decimals=3) %>%
    tab_footnote(
    footnote = "Stage 1 estimate: bivariate binomial partial-random effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(1,3))) %>%
    tab_footnote(
    footnote = "Stage 3 estimate: univariate fixed-effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 2)) %>%
  tab_footnote(
    footnote = "Stage 4 estimate: binomial test and exact CI",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 4)) %>%
  tab_footnote(
    footnote = "Stage 4 estimate: binomial test and exact CI",
    locations = cells_body(columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(2,4))) %>%
cols_align(align = "left", columns = naat) %>%
  tab_options(footnotes.marks=c("*","^","+",""))
gtnaatsum
```

### 5.2.7 Adding NAAT to integer model
```{r message=FALSE, warning=FALSE}
# All minipool test evaluations
mpnaat1 <- glmer (formula= cbind(true,n-true)~1+naat+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpnaat1_sum <- summary(mpnaat1)
mpnaat1_sum

# With pool size and naat
mpnaat2 <- glmer (formula= cbind(true,n-true)~1+naat+log2p+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpnaat2_sum <- summary(mpnaat2)
mpnaat2_sum
```


## 5.3 Symptom status

### 5.3.1 data preparation
```{r message=FALSE, warning=FALSE}
ympsx <- Y1mp %>% filter(symptoms=="Symptomatic")
ysempsx <- y1semp %>% filter(symptoms=="Symptomatic")
ympmix <-Y1mp %>% filter(symptoms=="Mixed")
ysempmix <- y1semp %>% filter(symptoms=="Mixed")
ympasx <-Y1mp %>% filter(symptoms=="Asymptomatic")
ysempasx <- y1semp %>% filter(symptoms=="Asymptomatic")
```

### 5.3.2 Symptomatic
Stage 1 As zero FNs bivariate binomial random-effects model failed to converge
Stage 2 Univariate random-effects model for sensitivity fit
Stage 4: Binomial test fit for specificity

```{r message=FALSE, warning=FALSE}
# Stage 1 model: bivariate binomial partial random-effects
mp_sx <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympsx,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_sx_sum <- summary(mp_sx)
mp_sx_sum
isSingular(mp_sx)

# Stage 2 model: univariate random-effects
mp_sxb <- glmer (formula= cbind(true,n-true)~0+sens+
(0+sens|testeval), data = ysempsx,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_sxb_sum<- summary(mp_sxb)
mp_sxb_sum
isSingular(mp_sxb)

set.seed (212)
mp_sxci <- confint (mp_sxb, level=0.99, method="boot", quiet=TRUE,nsim=200)
mp_sxci
mp_sx_spest <-binom.test(6720,6720)$estimate
mp_sx_spci<- binom.test(6720,6720)$conf.int
mp_sx_spci <- mp_sx_spci[1:2]
est_sx <- plogis (mp_sxb_sum$coefficients[1,1])
ci_sx <- plogis(mp_sxci[2,1:2])
mp_sx_ci <- rbind(ci_sx, mp_sx_spci)
mp_sx_est <-rbind(est_sx, mp_sx_spest)
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Symptomatic","Symptomatic")
sum_sx <- cbind(rowcat, lab47,mp_sx_est,mp_sx_ci)
sum_sx <- as.tibble(sum_sx)
sum_sx <- sum_sx %>% rename (parameter = lab47, estimate = `probability of success`, "lower 99% CI"= `0.5 %`, "upper 99% CI" = `99.5 %`)
sum_sx
```

### 5.3.3 Mixed
```{r message=FALSE, warning=FALSE}
# Stage 1 model: bivariate binomial partial random-effects

mp_mix <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympmix,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_mix_sum<- summary(mp_mix)
mp_mix_sum
isSingular(mp_mix)

set.seed (212)
mp_mix_ci <- confint (mp_mix, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_mix <- plogis (mp_mix_sum$coefficients[1:2,1])
ci_mix <- plogis(mp_mix_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Mixed","Mixed")
sum_mix <- cbind(rowcat, lab47,est_mix,ci_mix)
sum_mix <- as.tibble(sum_mix)
sum_mix <- sum_mix %>% rename (parameter = lab47, estimate = est_mix, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_mix
```

### 5.3.4 Asymptomatic
Since zero FN or FP fit both specificity and sensitivity with binomial tests and binomial exact CI
```{r message=FALSE, warning=FALSE}

# Stage 4: binomial tests
mp_asx_sens <-c(binom.test(296,296)$estimate, binom.test(296,296)$conf.int)
mp_asx_spec <-c(binom.test(2709,2709)$estimate, binom.test(2709,2709)$conf.int)
mp_asx <-(rbind(mp_asx_sens, mp_asx_spec))
mp_asx <- as.tibble(mp_asx)
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Asmptomatic","Asmptomatic")
sum_asx <- cbind(rowcat, lab47,mp_asx)
sum_asx <- as.tibble(sum_asx)
sum_asx <- sum_asx %>% rename (parameter = lab47, estimate = `probability of success`, "lower 99% CI"=V2, "upper 99% CI" = V3)
sum_asx

```

### 5.3.5 Summary table Symptom status
```{r message=FALSE, warning=FALSE}
sum_sx2 <- metadata %>% filter(pnaat=="Minipool") %>% group_by (symptoms) %>% summarise(Studies =n_distinct(study_id), Cohorts=n_distinct(cohort_id), "Test evaluations" = n_distinct(test_eval_id), "Participants" =sum(totalsamples),"SARS-CoV-2+"=sum(disease_p), TP=sum(t_p),                                                FN=sum(f_n),FP=sum(f_p),TN=sum(t_n))

sxsum <- rbind(sum_asx, sum_mix, sum_sx)
sxsum <- sxsum %>% pivot_wider(names_from = parameter, values_from = c(estimate, `lower 99% CI`, `upper 99% CI`))
sxsum2 <- sxsum %>% select(-rowcat) %>% mutate_if(is.character,as.numeric)
sxsum2 <- cbind(sum_sx2,sxsum2)
sxsum3 <- as.tibble(sxsum2)
gtsxsum <- gt(data = sxsum3) %>%
  tab_spanner(label = "Sensitivity",
    columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity")) %>%
  tab_spanner(label = "Specificity",
    columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity")) %>%
  cols_label(
    estimate_Specificity = html("Estimate"),
    "lower 99% CI_Specificity" = html("lower 99% CI"),
    "upper 99% CI_Specificity" = html("upper 99% CI"),
      estimate_Sensitivity = html("Estimate"),
    "lower 99% CI_Sensitivity" = html("lower 99% CI"),
    "upper 99% CI_Sensitivity" = html("upper 99% CI"),
     symptoms = html ("Symptom type")
  )%>%
 fmt_number(columns= c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), decimals=3) %>%
    tab_footnote(
    footnote = "Stage 1 estimate: bivariate binomial partial-random effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = 2)) %>%
    tab_footnote(
    footnote = "Stage 2 estimate: univariate random-effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 1)) %>%
  tab_footnote(
    footnote = "Stage 4 estimate: binomial test and exact CI",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity"), rows = 3)) %>%
  tab_footnote(
    footnote = "Stage 4 estimate: binomial test and exact CI",
    locations = cells_body(columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(1,3))) %>%
cols_align(align = "left", columns = symptoms) %>%
  tab_options(footnotes.marks=c("*","^","+",""))
gtsxsum
```


### 5.3.6 Adding symptoms to integer model
Unable to find a bivariate or univariate model that converges
```{r message=FALSE, warning=FALSE}
# Symptoms
mpsx1 <- glmer (formula= cbind(true,n-true)~1+symptoms+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpsx1_sum <- summary(mpsx1)
mpsx1_sum

# With pool size and symptoms
mpsx2 <- glm (formula= cbind(true,n-true)~1+symptoms,
                 data = y1semp,family=binomial)
mpsx2_sum <- summary(mpsx2)
mpsx2_sum
```

## 5.4 Sample type
### 5.4.1 data preparation
```{r message=FALSE, warning=FALSE}
ympurt <- Y1mp %>% filter(sample=="Upper respiratory tract swab")
ysempurt <- y1semp %>% filter(sample=="Upper respiratory tract swab")
ympsal <-Y1mp %>% filter(sample=="Saliva")
ysempsal <- y1semp %>% filter(sample=="Saliva")
```

### 5.4.2 URT swab
```{r message=FALSE, warning=FALSE}
# Stage 1 model: bivariate binomial partial random-effects

mp_urt <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympurt,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_urt_sum<- summary(mp_urt)
mp_urt_sum
isSingular(mp_urt)

set.seed (212)
mp_urt_ci <- confint (mp_urt, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_urt <- plogis (mp_urt_sum$coefficients[1:2,1])
ci_urt <- plogis(mp_urt_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("URT swab","URT swab")
sum_urt <- cbind(rowcat, lab47,est_urt,ci_urt)
sum_urt <- as.tibble(sum_urt)
sum_urt <- sum_urt %>% rename (parameter = lab47, estimate = est_urt, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_urt
```

### 5.4.3 Saliva
```{r message=FALSE, warning=FALSE}

# Stage 1 model: bivariate binomial partial random-effects

mp_sal <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympsal,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_sal_sum<- summary(mp_sal)
mp_sal_sum
isSingular(mp_sal)

set.seed (212)
mp_sal_ci <- confint (mp_sal, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_sal <- plogis (mp_sal_sum$coefficients[1:2,1])
ci_sal <- plogis(mp_sal_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Saliva","Saliva")
sum_sal <- cbind(rowcat, lab47,est_sal,ci_sal)
sum_sal <- as.tibble(sum_sal)
sum_sal <- sum_sal %>% rename (parameter = lab47, estimate = est_sal, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_sal
```

### 5.3.4 Summary table Sample type
```{r message=FALSE, warning=FALSE}
sum_samp2 <- metadata %>% filter(pnaat=="Minipool") %>% group_by (sample) %>% summarise(Studies =n_distinct(study_id), Cohorts=n_distinct(cohort_id), "Test evaluations" = n_distinct(test_eval_id), "Participants" =sum(totalsamples),"SARS-CoV-2+"=sum(disease_p), TP=sum(t_p),                                                FN=sum(f_n),FP=sum(f_p),TN=sum(t_n))
sum_samp2

sampsum <- rbind(sum_urt,sum_sal)
sampsum <- sampsum %>% pivot_wider(names_from = parameter, values_from = c(estimate, `lower 99% CI`, `upper 99% CI`))
sampsum2 <- sampsum %>% select(-rowcat) %>% mutate_if(is.character,as.numeric)
sampsum2 <- cbind(sum_samp2,sampsum2)
sampsum3 <- as.tibble(sampsum2)
gtsampsum <- gt(data = sampsum3) %>%
  tab_spanner(label = "Sensitivity",
    columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity")) %>%
  tab_spanner(label = "Specificity",
    columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity")) %>%
  cols_label(
    estimate_Specificity = html("Estimate"),
    "lower 99% CI_Specificity" = html("lower 99% CI"),
    "upper 99% CI_Specificity" = html("upper 99% CI"),
      estimate_Sensitivity = html("Estimate"),
    "lower 99% CI_Sensitivity" = html("lower 99% CI"),
    "upper 99% CI_Sensitivity" = html("upper 99% CI"),
     sample = html ("Sample type")
  )%>%
 fmt_number(columns= c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), decimals=3) %>%
    tab_footnote(
    footnote = "Stage 1 estimate: bivariate binomial partial-random effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(1,2))) %>%
cols_align(align = "left", columns = sample) %>%
  tab_options(footnotes.marks=c("*","^","+",""))
gtsampsum
```

### 5.3.5 Adding sample to integer model
```{r message=FALSE, warning=FALSE}
# Sample type
mpsamp1 <- glmer (formula= cbind(true,n-true)~1+sample+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpsamp1_sum <- summary(mpsamp1)
mpsamp1_sum

# With pool size and sample type
mpsamp1 <- glmer (formula= cbind(true,n-true)~1+sample+log2p+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
mpsamp1_sum <- summary(mpsamp1)
mpsamp1_sum
```

## 5.5 Pool type

### 5.5.1 data preparation
```{r message=FALSE, warning=FALSE}
ympMed <- Y1mp %>% filter(pool_type=="Media")
ysempMed <- y1semp %>% filter(pool_type=="Media")
ympMTT <-Y1mp %>% filter(pool_type=="Multitube")
ysempMTT <- y1semp %>% filter(pool_type=="Multitube")
ympRNA <- Y1mp %>% filter(pool_type=="RNA")
ysempRNA <- y1semp %>% filter(pool_type=="RNA")
ympDIR <-Y1mp %>% filter(pool_type=="Sample")
ysempDIR <- y1semp %>% filter(pool_type=="Sample")
```

### 5.5.2 swab media
```{r message=FALSE, warning=FALSE}

# Stage 1 model: bivariate binomial partial random-effects

mp_Med <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympMed,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_Med_sum<- summary(mp_Med)
mp_Med_sum
isSingular(mp_Med)

set.seed (212)
mp_Med_ci <- confint (mp_Med, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_Med <- plogis (mp_Med_sum$coefficients[1:2,1])
ci_Med <- plogis(mp_Med_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Transport Media","Transport Media")
sum_Med <- cbind(rowcat, lab47,est_Med,ci_Med)
sum_Med <- as.tibble(sum_Med)
sum_Med <- sum_Med %>% rename (parameter = lab47, estimate = est_Med, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_Med
```


### 5.5.3 multitube

```{r message=FALSE, warning=FALSE}

# Stage 4: binomial tests
mp_MTT_sens<-c(binom.test(106,106)$estimate, binom.test(
  106,106, conf.level=0.99)$conf.int)
mp_MTT_spec <-c(binom.test(657,657)$estimate, binom.test(
  657,657, conf.level = 0.99)$conf.int)
mp_MTT <-(rbind(mp_MTT_sens, mp_MTT_spec))
mp_MTT <- as.tibble(mp_MTT)
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Multitube","Multitube")
sum_MTT <- cbind(rowcat, lab47,mp_MTT)
sum_MTT <- as.tibble(sum_MTT)
sum_MTT <- sum_MTT %>% rename (parameter = lab47, estimate = `probability of success`, "lower 99% CI"=V2, "upper 99% CI" = V3)
sum_MTT

```

### 5.5.4 Direct
```{r message=FALSE, warning=FALSE}

# Stage 1 model: bivariate binomial partial random-effects

mp_DIR <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympDIR,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_DIR_sum<- summary(mp_DIR)
mp_DIR_sum
isSingular(mp_DIR)

set.seed (212)
mp_DIR_ci <- confint (mp_DIR, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_DIR <- plogis (mp_DIR_sum$coefficients[1:2,1])
ci_DIR <- plogis(mp_DIR_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("Sample (Direct)","Sample (Direct)")
sum_DIR <- cbind(rowcat, lab47,est_DIR,ci_DIR)
sum_DIR <- as.tibble(sum_DIR)
sum_DIR <- sum_DIR %>% rename (parameter = lab47, estimate = est_DIR, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_DIR
```






### 5.5.5 RNA
```{r message=FALSE, warning=FALSE}

# Stage 1 model: bivariate binomial partial random-effects

mp_RNA <- glmer (formula= cbind(true,n-true)~0+sens+spec+
(0+sens|testeval), data = ympRNA,
family=binomial, nAGQ=1,verbose=0) # fixed + random model
mp_RNA_sum<- summary(mp_RNA)
mp_RNA_sum
isSingular(mp_RNA)

set.seed (212)
mp_RNA_ci <- confint (mp_RNA, level=0.99, method="boot", quiet=TRUE,nsim=200)
est_RNA <- plogis (mp_RNA_sum$coefficients[1:2,1])
ci_RNA <- plogis(mp_RNA_ci[2:3,1:2])
lab47 <- c("Sensitivity","Specificity")
rowcat <- c("RNA (post-extraction)","RNA (post-extraction)")
sum_RNA <- cbind(rowcat, lab47,est_RNA,ci_RNA)
sum_RNA <- as.tibble(sum_RNA)
sum_RNA <- sum_RNA %>% rename (parameter = lab47, estimate = est_RNA, "lower 99% CI"=`0.5 %`, "upper 99% CI" = `99.5 %`)
sum_RNA
```




### 5.5.7 Summary table for pool type
```{r message=FALSE, warning=FALSE}
sum_ptype2 <- metadata %>% filter(pnaat=="Minipool") %>% group_by (pool_type) %>% summarise(Studies =n_distinct(study_id), Cohorts=n_distinct(cohort_id), "Test evaluations" = n_distinct(test_eval_id), "Participants" =sum(totalsamples),"SARS-CoV-2+"=sum(disease_p), TP=sum(t_p),                                                FN=sum(f_n),FP=sum(f_p),TN=sum(t_n))
sum_ptype2

ptypesum <- rbind(sum_Med, sum_MTT, sum_RNA, sum_DIR)
ptypesum <- ptypesum %>% pivot_wider(names_from = parameter, values_from = c(estimate, `lower 99% CI`, `upper 99% CI`))
ptypesum2 <- ptypesum %>% select(-rowcat) %>% mutate_if(is.character,as.numeric)
ptypesum2 <- cbind(sum_ptype2, ptypesum2)
ptypesum3 <- as.tibble(ptypesum2)
gtptypesum <- gt(data = ptypesum3) %>%
  tab_spanner(label = "Sensitivity",
    columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity")) %>%
  tab_spanner(label = "Specificity",
    columns = c("estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity")) %>%
  cols_label(
    estimate_Specificity = html("Estimate"),
    "lower 99% CI_Specificity" = html("lower 99% CI"),
    "upper 99% CI_Specificity" = html("upper 99% CI"),
      estimate_Sensitivity = html("Estimate"),
    "lower 99% CI_Sensitivity" = html("lower 99% CI"),
    "upper 99% CI_Sensitivity" = html("upper 99% CI"),
     pool_type = html ("Pool type")
  )%>%
 fmt_number(columns= c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), decimals=3) %>%
    tab_footnote(
    footnote = "Stage 1 estimate: bivariate binomial partial-random effects model",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = c(1,3,4))) %>%
      tab_footnote(
    footnote = "Stage 4 estimate: binomial test and 95% CI",
    locations = cells_body(columns = c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), rows = 2)) %>%
cols_align(align = "left", columns = pool_type) %>%
  tab_options(footnotes.marks=c("*","^","+",""))
gtptypesum
```

## 5.6 Summary all subgroups
```{r message=FALSE, warning=FALSE}
psum4 <-psum3 %>% rename (Subgroup= pool_size_gp)
naatsum4 <-naatsum3 %>% rename (Subgroup= naat)
sxsum4 <-sxsum3 %>% rename (Subgroup= symptoms)
sampsum4 <-sampsum3 %>% rename (Subgroup= sample)
ptypesum4 <-ptypesum3 %>% rename (Subgroup= pool_type)
subgp <- rbind(psum4, naatsum4, sxsum4, sampsum4, ptypesum4)
subgpgt <-gt(subgp) %>%
  tab_row_group("Pool type", rows = 15:18, id = "pooltype") %>%
tab_row_group("Sample type", rows = 13:14, id = "sample") %>%
  tab_row_group("Symptom status", rows = 10:12, id = "symptoms") %>%
  tab_row_group("NAAT type", rows = 6:9, id = "naat")%>%
   tab_row_group("Pool size", rows = 1:5, id = "pooln")  %>%
 fmt_number(columns= c("estimate_Sensitivity", "lower 99% CI_Sensitivity", "upper 99% CI_Sensitivity","estimate_Specificity", "lower 99% CI_Specificity", "upper 99% CI_Specificity"), decimals=3) %>%
   cols_merge(columns = c("lower 99% CI_Sensitivity","upper 99% CI_Sensitivity"),
    pattern = "{1}&mdash;{2}")  %>%
   cols_merge(columns = c("lower 99% CI_Specificity","upper 99% CI_Specificity"),
    pattern = "{1}&mdash;{2}") %>%
  cols_move(
    columns = "estimate_Specificity",
    after = "lower 99% CI_Sensitivity"
  ) %>%
  cols_label(
    estimate_Sensitivity = "Est.",
    estimate_Specificity = "Est.",
    "lower 99% CI_Sensitivity" = "99% CI",
    "lower 99% CI_Specificity" = "99% CI") %>%
  tab_spanner(
    label = "Sensitivity",
    columns = c(estimate_Sensitivity,"lower 99% CI_Sensitivity")) %>%
  tab_spanner(
    label = "Specificity",
    columns = c(estimate_Specificity,"lower 99% CI_Specificity")) %>%
  cols_align ("left", columns=Subgroup)
subgpgt
```

# 6. Meta-regression exploring heterogeneity
Meta-regressions were conducted for:

(a) Univariate binomial random-effects model:

* Outcome:Sensitivity 
* Variance assessed within (level 1) and between (level 2) test evaluations.

(b) Bivariate binomial partial random-effects model 
* Outcome: Sensitivity and specificity 
* Variance assessed within (level 1) and between (level 2) test evaluations.
* Random effects considered for sensitivity, but specificity modelled by fixed effects only.


* A block-wise backwards-elimination approach in which covariates were entered in groups (blocks) defined a priori on the basis of theoretical importance:
   * Block 1 (matchiing sub-groups): naat, symptoms, pool size, sample type,
   pooling method, proportion weak positives
   * Block 2: proportion pools containing >1 positive sample, quality group,
   limit of detection (lod), positivity rate
   * Block 3: modified protocol, modified interpretation, regulatory status,
   number of targets, number of targets amplified for positive result, target
   genes, storage of samples, reference standard same time, reference standard
   same sample, reference standard same assay.

* After entering the first block, we removed covariates, starting with those non-significantly associated with sensitivity and highly colinear with other variables. We reviewed BIC and likelihood-ratio after removing variables to determine if the covariate could be removed without compromising model fit. This continued until only covariates that were significant (at a=0.05) and improved model fit (according to lrtest) were retained.
* This process was applied for second and third rank blocks.

## 6.1 Exploring relationships between covariates and sensitivity
Before meta-regression we examine nature of relationships between independent variables (covariates) and outcomes (sensitivity, specificity):

### 6.1.1 Associations of continuous covariates and outcomes
* Since we use a logit link in the binomial model we examine relationships between the inverse logit of covariates and sensitivity (i.e TP as proportion of all with disease (TP+FN)).
* Continuous variables reflecting proportions (*weak_pos:* positives with low-viral load; *positivity_rate:* tested samples positive for SARS-CoV-2; *multipos:* positive pools containing >1 positive sample) were transformed by folded root [x^(1/2)-(1-x)^(1/2)] to ensure bounded by 0 and 1.
* We considered non-linear relationships between explanatory variables and outcomes

```{r message=FALSE, warning=FALSE}

y1semp<- y1semp %>% mutate(sensitivity = t_p/disease_p)
y1sempexp<- y1semp %>% mutate(logit = log(sensitivity/(1-sensitivity)))
y1semp_explore <- y1sempexp %>% dplyr::select(
  weak_posfold, multiposfold,positivity_ratefold, log2p, log2lod,logit,sensitivity, modified_interpret)
predictors <- colnames(y1semp_explore)


y1semp_explore1 <-y1semp_explore %>%
  gather(key = "predictors", value = "predictor.value", 
         -c(logit,sensitivity, weak_posfold, multiposfold, positivity_ratefold,
            modified_interpret))

plot1 <- ggplot(y1semp_explore1, aes(predictor.value, logit))+
  geom_point(size = 0.3, alpha = 0.5) +
  geom_smooth(method = "loess", size = 0.5) + 
  geom_smooth(method = "lm", color="darkred", linetype="dashed", size = 0.5, se=FALSE) + 
  facet_wrap(~predictors, scales = "free_x")+
  labs(y = "Logit Sensitivity", x = "Log 2 of Limit of detection (lod), Pool size (p), Modified cut-off+5")

y1semp_explore2 <-y1semp_explore %>%
  gather(key = "predictors", value = "predictor.value", 
         -c(logit,sensitivity, log2p, log2lod))

plot2 <- ggplot(y1semp_explore2, aes(predictor.value, logit))+
  geom_point(size = 0.3, alpha = 0.5) +
  geom_smooth(method = "loess", size = 0.5) + 
  geom_smooth(method = "lm", color="darkred", linetype="dashed", size = 0.5, se=FALSE) + 
  facet_wrap(~predictors, scales = "free_x")+
  labs(y = "Logit Sensitivity", x = "Folded root of x")

plot1
plot2
```
Observations:

*  Log2 of pool size (*log2p*) and the (folded root of) proportion of positives having low viral load (*weak_posfold*) were linearly and inversely associated with logit of sensitivity as anticipated.
* Less clear associations were seen with log 2 of the assay limit of detection (*log2lod*), proportion of positive pools containing more than 1 positive (*multiposfold*), and all were adequately described by linear relationships after appropriate transformations.

### 6.1.2 Correlations between continuous covariates
Correlations were generally weak except for relations between pool size (log2p) and test positivity rate (-0.583) or multiple positives per pool (+0.479).
```{r message=FALSE, warning=FALSE}

y1sempexp2 <- as_tibble(y1sempexp)
explanatory <-y1sempexp2 %>% dplyr::select(log2p,multiposfold,log2lod,weak_posfold, positivity_ratefold)
write_csv(explanatory, "exp.csv")
cont <- read_csv("exp.csv")
GGally::ggpairs(cont, columns=1:5)
```

### 6.1.3 Homogeneity of variance between factor levels
```{r message=FALSE, warning=FALSE}

lt1<- leveneTest(residuals(ysemp2) ~ y1semp$naat)
lt2<- leveneTest(residuals(ysemp2) ~ y1semp$sample)
lt3<- leveneTest(residuals(ysemp2) ~ y1semp$modified_protocol)
lt4<- leveneTest(residuals(ysemp2) ~ y1semp$reg)
lt<- rbind(lt1[1,1:3],lt2[1,1:3],lt3[1,1:3],lt4[1,1:3])
covariate <- c("NAAT type", "Sample type", "Modified protocol", "Regulatory authorisation")
lt <- cbind(covariate,lt)
lt
```


```{r message=FALSE, warning=FALSE}
y1sempexp<- as.tibble(y1sempexp)
y1sempexp$sample <- dplyr::recode_factor (y1sempexp$sample, "Upper respiratory tract swab" = "URT Swab")

cvarp1<- ggplot(y1sempexp, aes(x=naat,y=sensitivity, colour=naat)) + geom_boxplot()+
geom_jitter(alpha=0.2)+ coord_flip() + theme(legend.position="none")+scale_y_continuous(
  breaks=seq(0,1,0.1), limits=c(0.5,1))
cvarp2<- ggplot(y1sempexp, aes(x=naat,y=logit, colour=naat)) + geom_boxplot()+
geom_jitter(alpha=0.2)+ coord_flip() + theme(legend.position="none")
cvarp3<- ggplot(y1sempexp, aes(x=sample ,y=sensitivity, colour=sample))+ geom_boxplot ()+
geom_jitter(alpha=0.2) + coord_flip() + theme(legend.position="none")
cvarp4<- ggplot(y1sempexp, aes(x=sample ,y=logit, colour=sample))+ geom_boxplot ()+
geom_jitter(alpha=0.2) + coord_flip() + theme(legend.position="none")
cvarp5<- ggplot(y1sempexp, aes(x=modified_protocol,y=sensitivity, colour=modified_protocol)) + geom_boxplot() + theme(legend.position="none")+ geom_jitter(alpha=0.2) + coord_flip()
cvarp6<- ggplot(y1sempexp, aes(x=modified_protocol,y=logit, colour=modified_protocol)) + geom_boxplot() + theme(legend.position="none")+ geom_jitter(alpha=0.2) + coord_flip()
cvarp7<- ggplot(y1sempexp, aes(x=reg,y=sensitivity, colour=reg)) + geom_boxplot() + theme(legend.position="none")+ geom_jitter(alpha=0.2) + coord_flip()
cvarp8<- ggplot(y1sempexp, aes(x=reg, y=logit, colour=reg)) + theme(legend.position="none")+ geom_jitter(alpha=0.2) + coord_flip()
a<- ggarrange(cvarp1,cvarp2)
b<- ggarrange(cvarp3,cvarp4)
c<- ggarrange(cvarp5,cvarp6)
d<- ggarrange(cvarp7,cvarp8)
ggarrange(a,b,c,d, nrow = 4)

```

## 6.2 Models with Random effects at test evaluation level

### 6.2.1 Block 1 model
Variables considered in block 1 reflected those selected a priori to be most important
* log2 of pool size
* % weak positives
* NAAT type
* Symptom status
* Sample type
* Pooling method

#### Block 1 Saturated model
Adding all variables
```{r message=FALSE, warning=FALSE}

# Saturated Block 1 model 
ysemp4 <- glmer (formula= cbind(true,n-true)~ 1+weak_posfold+naat+symptoms+log2p+sample+pool_type+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp4_sum <- summary(ysemp4)
ysemp4_sum
```

#### Block 1 Best Fit model
```{r message=FALSE, warning=FALSE}
ysemp5 <- glmer (formula= cbind(true,n-true)~ 1+weak_posfold+naat+log2p+pool_type+(1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp5_sum <- summary(ysemp5)
ysemp5_sum
lrtest(ysemp4,ysemp5)
```
### 6.2.2 Block 2 model
Variables considered:

* 
#### Block 2 saturated model
```{r message=FALSE, warning=FALSE}

ysemp6 <- glmer (formula= cbind(true,n-true)~ 1+weak_posfold+naat+log2p+pool_type+multiposfold+quality+log2lod+positivity_ratefold+ (1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp6_sum <- summary(ysemp6)
ysemp6_sum
```

#### Block 2 Best Fit model
```{r message=FALSE, warning=FALSE}
ysemp7 <- glmer (formula= cbind(true,n-true)~ 1+weak_posfold+log2p+naat+pool_type+
                   (1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp7_sum <- summary(ysemp7)
ysemp7_sum
lrtest(ysemp6,ysemp7)
```

### 6.2.3 Block 3 model
Variables considered:

* modified protocol, 
* modified interpretation, 
* regulatory status
* number of targets, 
* number of targets amplified for positive result, 
* target genes, 
* storage of samples, 
* reference standard same cut-off 
* reference standard same assay.

#### Block 3 staturated model
```{r message=FALSE, warning=FALSE}

ysemp8 <- glmer (formula= cbind(true,n-true)~1+weak_posfold+naat+log2p
                 +sample+modified_protocol+modified_interpret+reg+storage+refst_same_cutoff+refstd_same_assay+
                   (1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp8_sum <- summary(ysemp8)
ysemp8_sum

```

#### Block 3 (final) best fit model
```{r message=FALSE, warning=FALSE}
ysemp9 <- glmer (formula= cbind(true,n-true)~1+naat+log2p
                 +sample+modified_protocol+weak_posfold+modified_interpret+reg+
                   (1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp9_sum <- summary(ysemp9)
ysemp9_sum
lrtest(ysemp8,ysemp9)

```

### 6.2.4 Diagnostics on final block 3 model
```{r message=FALSE, warning=FALSE}
# Obtain residuals
simulationOutput <- simulateResiduals(ysemp9, plot = T)

# Check for under/over dispersion
testDispersion(simulationOutput)

# Check of residuals against predictors
testCategorical(simulationOutput, catPred = y1semp$reg)
testCategorical(simulationOutput, catPred = y1semp$naat)
testCategorical(simulationOutput, catPred = y1semp$modified_protocol)

# Check for homogeneity of variance over range of continuous variables
testQuantiles(simulationOutput, predictor=y1semp$weak_posfold, plot=T)
testQuantiles(simulationOutput, predictor=y1semp$log2p, plot=T)
testQuantiles(simulationOutput, predictor=y1semp$modified_interpret, plot=T)

# Check for homogeneity of variance between categories of factors
leveneTest(residuals(ysemp9) ~ y1semp$naat)
leveneTest(residuals(ysemp9) ~ y1semp$sample)
leveneTest(residuals(ysemp9) ~ y1semp$modified_protocol)
leveneTest(residuals(ysemp9) ~ y1semp$reg)

# Check for multi-colinearity by VIF
car::vif(ysemp9) 
```

### 6.2.5 A model with basis splines for *weak_posfold* and *modified_interpret*
```{r message=FALSE, warning=FALSE}
ysemp10 <- glmer (formula= cbind(true,n-true)~1+naat+log2p+
                 sample+modified_protocol+bs(weak_posfold)+
                 bs(modified_interpret)+ reg+ (1|testeval),
                 data = y1semp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ysemp10_sum <- summary(ysemp10)
ysemp10_sum
lrtest(ysemp9,ysemp10)

# Obtain residuals
sim2 <- simulateResiduals(ysemp10, plot = T)

# Check for under/over dispersion
testDispersion(sim2)

# Check of residuals against predictors
testCategorical(sim2, catPred = y1semp$reg)
testCategorical(sim2, catPred = y1semp$naat)
testCategorical(sim2, catPred = y1semp$modified_protocol)

# Check for homogeneity of variance over range of continuous variables
testQuantiles(sim2, predictor=y1semp$weak_posfold, plot=T)
testQuantiles(sim2, predictor=y1semp$log2p, plot=T)
testQuantiles(sim2, predictor=y1semp$modified_interpret, plot=T)

# Check for homogeneity of variance between categories of factors
leveneTest(residuals(ysemp10) ~ y1semp$naat)
leveneTest(residuals(ysemp10) ~ y1semp$sample)
leveneTest(residuals(ysemp10) ~ y1semp$modified_protocol)
leveneTest(residuals(ysemp10) ~ y1semp$reg)

# Check for multi-colinearity by VIF
car::vif(ysemp10) 

plot_model(ysemp10, type = "eff", terms ="modified_interpret [all]")+ ylim (0,1)
plot_model(ysemp10, type = "eff", terms ="weak_posfold [all]")+ ylim (0,1)

```

Observations:

* Diagnostics on the final metaregression model suggest adequate overall fit, but potential misspecification of the functional relationship between *weak_posfold* (folded root of proportion positives with low viral load) and sensitivity.
* Fitting a model (*ysemp10*) with basis splines for *weak_posfold* and *modified_interpret* improved overall model fit (log-likelihood) but at expense of higher model complexity (BIC unchanged).
* The basis splines may be overfitting given limited data across some parts of the range of *weak_posfold* and *modified_interpret*
* To aid interpretability we have settled on *ysemp9* as the final metaregression.



### 6.2.6 Summarising block-wise metaregression

#### Summary table
```{r message=FALSE, warning=FALSE}
#### Summarising metaregression (a) results
ysemp9_table <- tab_model (ysemp2, ysemp7,ysemp9, 
                           show.p=FALSE, collapse.ci = TRUE,  show.reflvl = TRUE,
  pred.labels=c("Intercept","Weak positives (fsqroot)", "NAAT: digital PCR","NAAT: TMA", "log 2 of pool size","Sample type: saliva","Modified test protocol", "Modified pool test cut-off", "Regulatory approval: yes"),
  dv.labels=c("(A) Intercept only","(B) Block 1 and 2","(C) Block 3"))
ysemp9_table
```

#### Summary of importance of covariates (MAY TAKE TIME TO RUN)
```{r message=FALSE, warning=FALSE}
R2_9m <- partR2(ysemp9, data = y1semp, R2_type = "marginal", nboot = 10)
R2_9m
R2_9parts <- partR2(ysemp9, data = y1semp, partvars = c("reg", "naat","modified_interpret","modified_protocol","sample","log2p","weak_posfold"), R2_type= "marginal", nboot=10)
summary(R2_9parts)
```

#### Plots summarising sources of heterogeneity
```{r message=FALSE, warning=FALSE}
# "EFFECTS" PACKAGE EXAMPLES

# Plot modified_intepret
plot1 <- plot(predictorEffects(ysemp10,~ modified_interpret, residuals=TRUE),
     main="Modifed pool test cut-off", 
     axes = list(grid=TRUE,x=list(rug=TRUE, pool_size=list(lab ="Change in Cq cut-off(pool-standard)")), y=list(lab="Sensitivity", type="response",lim=c(0,1), ticks=list(at=c(0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0)))),
      partial.residuals=list(smooth=FALSE))

# Plot weak_posfold
plot2 <-plot(predictorEffects(ysemp10,~ weak_posfold, residuals = TRUE),
     main="Proportion of positives with low VL", 
     axes = list(grid=TRUE,x=list(rug=TRUE, pool_size=list(lab ="Proportion low VL")), y=list(lab="Sensitivity", type="response",lim=c(0,1), ticks=list(at=c(0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0)))),
     partial.residuals=list(smooth=FALSE))

# Plot log2p (pool size)
plot3 <- plot(predictorEffects(ysemp10,~log2p,residuals = TRUE), 
     main="Pool size", 
     axes = list(grid=TRUE,x=list(rug=TRUE, log2p=list(lab ="Pool size",
      ticks=list(at=c(2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32)))), y=list(lab="Sensitivity", type="response",lim=c(0,1), ticks=list(at=c(0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0)))),
     partial.residuals=list(smooth=FALSE))

```



```{r message=FALSE, warning=FALSE}
# "sjPlot" PACKAGE EXAMPLES

set_theme(base = theme_grey())
# Plot of Odds Ratios and Beta-coefficients (standardised coefficients)
por <- plot_model(ysemp9,sort.est=T, title = "Effects as Odds Ratios")
pbeta <- plot_model(ysemp9,sort.est=T, type = "std", title = "Beta-coefficients")
p <- ggplot(R2IR2, aes(x=reorder(term, estimate),y=estimate))
p + geom_pointrange(aes(ymin = CI_lower, ymax = CI_upper)) + coord_flip()+ 
    ggtitle("Inclusive R2") +
  xlab("Covariate") + ylab("R2")
por
pbeta


pool1 = function(x){
  2^(x+2.85895883542674)
}
pool2 = function(x){
   x<-ifelse(x<0, 0, x)
   log(x,2) - 2.85895883542674
 }

isq<-function(x){
  print(paste("isq",x))  #debug statement
  x<-ifelse(x<0, 0, x)
  sqrt(x)
}

plot_model(ysemp9, type="eff",terms=c("log2p","sample","naat"))+
  ggtitle("Marginal effects by pool size, sample type and NAAT type") +
  theme(legend.position="top")+
  scale_y_continuous(name = "Sensitivity", breaks=seq(0,1.0,0.1), labels = scales::percent)+
  scale_x_continuous(trans=scales::trans_new("sq", pool1, pool2))
#### Look into trans_new from scales package
```



```{r message=FALSE, warning=FALSE}
# "ggeffects" PACKAGE EXAMPLES
theme_set(theme_ggeffects())
sampletype <- ggeffect(ysemp9, terms = c("log2p", "sample", "naat","weak_posfold [meansd]"))
sampletype <- sampletype %>% mutate(x = x+2.85895883542674)

sampletype2 <- ggemmeans(ysemp9, terms = c("log2p", "sample", "naat"), type="re",
                         condition=c(weak_posfold=-0.43408208))
sampletype2 <- sampletype2 %>% mutate(x = x+2.85895883542674)

ggplot(sampletype2, aes(x = x, y = predicted, group = group, colour = group, 
                       fill=group)) + 
  geom_line()+
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill=group), linetype=0, alpha = .2) +
facet_wrap(~facet) +
  scale_x_continuous("Pool size", breaks=c(0,1,2,3,4,5), labels=function(x){2^x})+
  scale_y_continuous("Sensitivity", breaks=seq(0,1,0.1))+
  theme(legend.position="top")+
  theme(panel.grid.minor = element_blank())+
  labs(title="Marginal effects by NAAT type, sample type, and pool size",
  fill= "Sample type", colour = "Sample type")

plot(sampletype2, facet = TRUE)+
  labs(title="Marginal effects by NAAT type, sample type, and pool size",
  colour="Sample type", fill="Sample type")+
  scale_x_continuous("Pool size", breaks=c(0,1,2,3,4,5), labels=function(x){2^x})+
  scale_y_continuous("Sensitivity", breaks=seq(0,1,0.1))+
  theme(legend.position="top")+
  theme(panel.grid.minor = element_blank())
```    
     
## 6.3 Metaregression with test evaluation random effects for sensitivity and fixed specificity
```{r message=FALSE, warning=FALSE}
Y1mp <- Y1mp %>% mutate(selog2p = log2p*sens)
Y1mp <- Y1mp %>% mutate(splog2p = log2p*spec)
Y1mp <- Y1mp %>% mutate(sereg = reg*sens)
Y1mp <- Y1mp %>% mutate(spreg = reg*spec)
Y1mp <- Y1mp %>% mutate(semodified_interpret = modified_interpret*sens)
Y1mp <- Y1mp %>% mutate(semod_protocol = modified_protocol*sens)
Y1mp <- Y1mp %>% mutate(seweak_pos = weak_pos*sens)
Y1mp <- Y1mp %>% mutate(spweak_pos = weak_pos*spec)
Y1mp <- Y1mp %>% mutate(senaat2 = naat2*sens)
Y1mp <- Y1mp %>% mutate(spnaat2 = naat2*spec)
Y1mp <- Y1mp %>% mutate(semultipos = multipos*sens)
Y1mp <- Y1mp %>% mutate(senaat2 = as.factor(senaat2))
Y1mp <- Y1mp %>% mutate(samp = if_else(sample=="Upper respiratory tract swab",1,0))
Y1mp <- Y1mp %>% mutate(sesamp=samp*sens)
Y1mp <- Y1mp %>% mutate(sesamp = as.factor(sesamp))
Y1mp$senaat2 <- fct_relevel(Y1mp$senaat2,"3","2","1","0")
Y1mp <- Y1mp %>% mutate(modprot = if_else(modified_protocol=="T",1,0))
Y1mp <- Y1mp %>% mutate(modprot=modprot*sens)
Y1mp <- Y1mp %>% mutate(semodprot = as.factor(modprot))
```

```{r message=FALSE, warning=FALSE}
ypartmp17 <- glmer (formula= cbind(true,n-true)~0+spec+sens+selog2p+seweak_pos+senaat2+sesamp+semodified_interpret+semodprot+sereg+(0+sens|testeval),
                 data = Y1mp,family=binomial, nAGQ=1,verbose=0,
                 control=glmerControl(optimizer="bobyqa",optCtrl=list
                                      (maxfun=2e5)))
ypartmp17_sum <- summary(ypartmp17)
ypartmp17_sum
ypartmp17_residuals <-simulateResiduals(ypartmp17, plot = T)
testDispersion(ypartmp17_residuals)
```

# 7. Test comparison

# 8. Sensitivity analysis

# 9. Bayesian implementation

```{r message=FALSE, warning=FALSE}

bayesian <- metadata %>% dplyr::select(eval_id, test_eval_id,
                                       cohort_id,t_p,f_n,f_p,t_n,disease_p, disease_n,
                                  pnaat, pool_size_gp,pool_size,naat,symptoms, sample, pool_type, sample_pool, log2p,modified_protocol,modified_interpret,
                                  reg, log2lod, num_target,index_assay)
bayesian <- bayesian %>% dplyr::rename(studynames = test_eval_id, TP = t_p, FN = f_n,
                                       FP = f_p, TN = t_n, n1 = disease_p, n2 = disease_n)
```

## 9.2 Summary estimates

### 9.2.1 Combinatorial
To obtain 95% CI by Bayesian inference, we used both default and user-defined values for the shape parameters 'a' and 'b' describing the prior beta distribution for binomial outcomes.
User-defined values for 'a' and 'b' were identified from a priori estimates of 50th and 90th centiles of sensitivity (0.90 and 0.98) and specificity (0.970 and 0.999)

```{r message=FALSE, warning=FALSE}

sens_ab <- beta.select(list(x = 0.90, p = 0.5), list(x = 0.98, p = 0.9))
spec_ab <- beta.select(list(x = 0.97, p = 0.5), list(x = 0.999, p = 0.9))

# Sensitivity Using user-defined values
ycombaysian_sens <- binom.bayes(25,25,prior.shape1 = sens_ab[1], prior.shape2 = sens_ab[2])
print(ycombaysian_sens)
binom.bayes.densityplot(ycombaysian_sens)

# Sensitivity Using  defaults
ycombaysian_sens2 <- binom.bayes(25,25,prior.shape1 = 0.5, prior.shape2 =0.5)
print(ycombaysian_sens2)
binom.bayes.densityplot(ycombaysian_sens2)

# Specificity using user-defined
ycombaysian_spec <- binom.bayes(1765,1766,prior.shape1 = spec_ab[1], prior.shape2 = spec_ab[2])
print(ycombaysian_spec)
binom.bayes.densityplot(ycombaysian_spec)

# Specificity using defaults
ycombaysian_spec2 <- binom.bayes(1765,1766,prior.shape1 = 0.5, prior.shape2 =0.5)
print(ycombaysian_spec2)
binom.bayes.densityplot(ycombaysian_spec2)
```

### 9.2.2 Matrix
#### Estimate sens and spec (and 95% CIs) using Bayesian method
To obtain 95% CI by Bayesian inference, we used both default and user-defined values for the shape parameters 'a' and 'b' describing the prior beta distribution for binomial outcomes.
User-defined values for 'a' and 'b' were identified from a priori estimates of 50th and 90th centiles of sensitivity (0.90 and 0.98) and specificity (0.970 and 0.999)

```{r message=FALSE, warning=FALSE}

sens_ab <- beta.select(list(x = 0.90, p = 0.5), list(x = 0.98, p = 0.9))
spec_ab <- beta.select(list(x = 0.97, p = 0.5), list(x = 0.999, p = 0.9))

# Sensitivity by user-defined values
ymatbaysian_sens <- binom.bayes(3,3,prior.shape1 = sens_ab[1], prior.shape2 = sens_ab[2])
print(ymatbaysian_sens)
binom.bayes.densityplot(ymatbaysian_sens)

# Sensitivity by default values
ymatbaysian_sens2 <- binom.bayes(3,3,prior.shape1 = 0.5, prior.shape2 =0.5)
print(ymatbaysian_sens2)
binom.bayes.densityplot(ymatbaysian_sens2)

# Specificity by user-defined values
ymatbaysian_spec <- binom.bayes(72,72,prior.shape1 = spec_ab[1], prior.shape2 = spec_ab[2])
print(ymatbaysian_spec)
binom.bayes.densityplot(ymatbaysian_spec)

# Specificity by default values
ymatbaysian_spec2 <- binom.bayes(72,72,prior.shape1 = 0.5, prior.shape2 =0.5)
print(ymatbaysian_spec2)
binom.bayes.densityplot(ymatbaysian_spec2)
```

### 9.2.3 Minipool (all)
```{r message=FALSE, warning=FALSE}

Bmpall <- bayesian %>% filter(pnaat == "Minipool")

outpriors = makePriors(var.prior = "PC", 
                    var2.prior = "PC",
                    cor.prior = "PC",
                    var.par = c(3, 0.05),  
                    var2.par = c(0.1, 0.05), 
                    cor.par = c(3, 0, NA, -0.5, 0.01, 0.5, 0.01),
                    init = c(0.01, 0.01, -0.1))

outdata = makeData(Bmpall, model.type = 1, modality = NULL, covariates = NULL)
set.seed(18674)
BMinipool<- runModel(outdata, outpriors, link="logit", quantiles=c(0.025,0.5,0.975), verbose=FALSE)

BMPout = makeObject(model = BMinipool, nsample =  1000 )

plot(BMPout, var.type = "mu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMPout, var.type = "nu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMPout, var.type = "var1", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMPout, var.type = "var2", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMPout, var.type = "rho", overlay.prior = TRUE, lwd = 2, save = FALSE)
forest(BMPout, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",nameShow="left", dataShow="right", estShow="center", text.cex=0.8,shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,cut=TRUE, intervals=c(0.025,0.975),main="Forest plot", main.cex=1, axis.cex=1)
```

## 9.3 Sub-group analyses

### 9.3.1 Pool sizes

#### Minipool of 2

##### bamdit
```{r message=FALSE, warning=FALSE}
set.seed(2017)
# Filter for minipool  size 4 to 7
confmatrix2 <- confmatrix %>% mutate(n1 = TP+FN)
confmatrix2 <- confmatrix2 %>% mutate(n2 = FP+TN)
confmatrix2 <- confmatrix2 %>% mutate(Study =as.character(Study))
confmatrix2 <- confmatrix2 %>% filter(pool_size_gp == "2")


result <- metadiag(confmatrix2, two.by.two=TRUE, re = "normal", re.model = "DS", link = "logit", sd.Fisher.rho = 1.7, nr.burnin = 1000, nr.iterations = 5000, nr.chains = 4, r2jags = TRUE)

plot(result, level = 0.5, parametric.smooth = TRUE)

plotsesp(result)
summary(result, digits = 3, intervals = c(0.025,0.5, 0.975))
```

##### meta4diag
```{r message=FALSE, warning=FALSE}
                    
outdata = makeData(Bmpall[Bmpall$pool_size_gp =="2",], model.type = 1, modality = NULL, covariates = NULL)
set.seed(18674)
BMinipool<- runModel(outdata, outpriors, link="logit", quantiles=c(0.025,0.5,0.975), verbose=FALSE)

BMP2out = makeObject(model = BMinipool, nsample =  1000 )

plot(BMP2out, var.type = "mu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP2out, var.type = "nu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP2out, var.type = "var1", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP2out, var.type = "var2", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP2out, var.type = "rho", overlay.prior = TRUE, lwd = 2, save = FALSE)
forest(BMP2out, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",nameShow="left", dataShow="right", estShow="center", text.cex=0.8,shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,cut=TRUE, intervals=c(0.025,0.975),main="Forest plot", main.cex=1, axis.cex=1)
```
#### Minipool of 4 to 7
```{r message=FALSE, warning=FALSE}
set.seed(2017)
# Filter for minipool  size 4 to 7
confmatrix2 <- confmatrix %>% mutate(n1 = TP+FN)
confmatrix2 <- confmatrix2 %>% mutate(n2 = FP+TN)
confmatrix2 <- confmatrix2 %>% mutate(Study =as.character(Study))
confmatrix4 <- confmatrix2 %>% filter(pool_size_gp == "4 to 7")


result <- metadiag(confmatrix4, two.by.two=TRUE, re = "normal", re.model = "DS", link = "logit", sd.Fisher.rho = 1.7, nr.burnin = 1000, nr.iterations = 5000, nr.chains = 4, r2jags = TRUE)

plot(result, level = 0.5, parametric.smooth = TRUE)

plotsesp(result)
summary(result, digits = 3, intervals = c(0.025,0.5, 0.975))
```



```{r message=FALSE, warning=FALSE}

outdata4 = makeData(data =Bmpall[Bmpall$pool_size_gp =="4 to 7",], model.type = 1, modality = NULL, covariates = NULL)

bm4<- runModel(outdata4, outpriors, link="logit", quantiles=c(0.025,0.5,0.975), verbose=FALSE)

BMP4out = makeObject(model = bm4, nsample = 1000)

plot(BMP4out, var.type = "mu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "nu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "var1", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "var2", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "rho", overlay.prior = TRUE, lwd = 2, save = FALSE)
forest(BMP4out, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",nameShow="left", dataShow="right", estShow="center", text.cex=0.8,shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,cut=TRUE, intervals=c(0.025,0.975),main="Forest plot", main.cex=1, axis.cex=1)
```
#### Minipool of 8 to 15
```{r message=FALSE, warning=FALSE}

outdata8 = makeData(data =Bmpall[Bmpall$pool_size_gp =="8 to 15",], model.type = 1, modality = NULL, covariates = NULL)

bm<- runModel(outdata4, outpriors, link="logit", quantiles=c(0.025,0.5,0.975), verbose=FALSE)

BMP8out = makeObject(model = bm, nsample=1000)

plot(BMP8out, var.type = "mu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP8out, var.type = "nu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP8out, var.type = "var1", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP8out, var.type = "var2", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP8out, var.type = "rho", overlay.prior = TRUE, lwd = 2, save = FALSE)
forest(BMP4out, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",nameShow="left", dataShow="right", estShow="center", text.cex=0.8,shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,cut=TRUE, intervals=c(0.025,0.975),main="Forest plot", main.cex=1, axis.cex=1)
```


```{r message=FALSE, warning=FALSE}

outdata4 = makeData(data =Bmpall[Bmpall$pool_size_gp =="4 to 7",], model.type = 1, modality = NULL, covariates = NULL)

bm4<- runModel(outdata4, outpriors, link="logit", quantiles=c(0.025,0.5,0.975), verbose=FALSE)

BMP4out = makeObject(model = bm4, nsample =  =1000)

plot(BMP4out, var.type = "mu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "nu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "var1", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "var2", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "rho", overlay.prior = TRUE, lwd = 2, save = FALSE)
forest(BMP4out, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",nameShow="left", dataShow="right", estShow="center", text.cex=0.8,shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,cut=TRUE, intervals=c(0.025,0.975),main="Forest plot", main.cex=1, axis.cex=1)
```

```{r message=FALSE, warning=FALSE}

outdata4 = makeData(data =Bmpall[Bmpall$pool_size_gp =="4 to 7",], model.type = 1, modality = NULL, covariates = NULL)

bm4<- runModel(outdata4, outpriors, link="logit", quantiles=c(0.025,0.5,0.975), verbose=FALSE)

BMP4out = makeObject(model = bm4, nsample =  =1000)

plot(BMP4out, var.type = "mu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "nu", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "var1", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "var2", overlay.prior = TRUE, lwd = 2, save = FALSE)
plot(BMP4out, var.type = "rho", overlay.prior = TRUE, lwd = 2, save = FALSE)
forest(BMP4out, accuracy.type="sens", est.type="mean", p.cex="scaled", p.pch=15, p.col="black",nameShow="left", dataShow="right", estShow="center", text.cex=0.8,shade.col="gray", arrow.col="black", arrow.lty=1, arrow.lwd=1,cut=TRUE, intervals=c(0.025,0.975),main="Forest plot", main.cex=1, axis.cex=1)
```

## 9.4 Metaregression

## 9.5 Sensitivity analysis


